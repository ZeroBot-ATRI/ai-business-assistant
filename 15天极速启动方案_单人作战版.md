# ä¼ä¸šAIåŠ©æ‰‹ - 15å¤©æé€Ÿå¯åŠ¨æ–¹æ¡ˆï¼ˆå•äººä½œæˆ˜ç‰ˆï¼‰

## æˆ˜ç•¥æ€è·¯ï¼šç æ‰80%ï¼Œä¿ç•™20%æ ¸å¿ƒä»·å€¼

**æ ¸å¿ƒåŸåˆ™**ï¼š
- âŒ ä¸åšå¾®æœåŠ¡ï¼Œå•ä½“åº”ç”¨å¿«é€Ÿå¯åŠ¨
- âŒ ä¸åšå¤æ‚æ¶æ„ï¼Œèƒ½ç”¨ç°æˆå·¥å…·ç»ä¸è‡ªå·±å†™
- âŒ ä¸åšå®Œç¾ï¼Œå…ˆè·‘é€šå†ä¼˜åŒ–
- âœ… ä½¿ç”¨æœ€æˆç†Ÿçš„æ¡†æ¶å’Œå·¥å…·
- âœ… äº‘æœåŠ¡èƒ½è§£å†³çš„ä¸è‡ªå»º
- âœ… åŠŸèƒ½èƒ½ç åˆ™ç ï¼Œä¸“æ³¨æ ¸å¿ƒæµç¨‹

---

## é˜¶æ®µ1: 15å¤©æé™å†²åˆº - è·‘é€šç«¯åˆ°ç«¯

**ç›®æ ‡**: è¯æ˜æŠ€æœ¯å¯è¡Œæ€§ï¼Œå±•ç¤ºç»™è€æ¿çœ‹

### Day 1-2: ç¯å¢ƒé€Ÿé… (å…³é”®ï¼)

```bash
# æŠ€æœ¯æ ˆé€‰æ‹©ï¼šæœ€å¿«ä¸Šæ‰‹çš„ç»„åˆ
1. åç«¯ï¼šFastAPI (Python) - æœ€å¿«çš„APIæ¡†æ¶
2. å‰ç«¯ï¼šStreamlit - é›¶å‰ç«¯ç»éªŒä¹Ÿèƒ½åšUI
3. æ•°æ®åº“ï¼šSQLite - å¼€å‘é˜¶æ®µå¤Ÿç”¨
4. LLMï¼šClaude API - ç›´æ¥è°ƒç”¨ï¼Œæ— éœ€éƒ¨ç½²
5. éƒ¨ç½²ï¼šRailway/Render - å…è´¹æ‰˜ç®¡ï¼Œä¸€é”®éƒ¨ç½²

# Day 1ä¸Šåˆï¼šæœ¬åœ°ç¯å¢ƒ
pip install fastapi uvicorn anthropic sqlalchemy streamlit pydantic

# Day 1ä¸‹åˆï¼šé¡¹ç›®ç»“æ„ï¼ˆè¶…ç®€åŒ–ç‰ˆï¼‰
/ai-assistant
  /app
    main.py          # FastAPIä¸»ç¨‹åºï¼ˆ200è¡Œæå®šï¼‰
    models.py        # æ•°æ®æ¨¡å‹
    orchestrator.py  # AIç¼–æ’å™¨ï¼ˆæ ¸å¿ƒï¼‰
    skills.py        # æŠ€èƒ½å‡½æ•°
  /ui
    app.py           # Streamlitç•Œé¢ï¼ˆ100è¡Œï¼‰
  database.db        # SQLiteæ•°æ®åº“
  .env              # é…ç½®æ–‡ä»¶
  requirements.txt

# Day 2ï¼šæ ¸å¿ƒä»£ç éª¨æ¶
```

**Day 1å®æˆ˜ä»£ç **ï¼š

```python
# app/main.py - æ ¸å¿ƒAPIï¼ˆæç®€ç‰ˆï¼‰
from fastapi import FastAPI, HTTPException
from anthropic import Anthropic
import os
from datetime import datetime
import sqlite3

app = FastAPI(title="AI Business Assistant")
client = Anthropic(api_key=os.getenv("CLAUDE_API_KEY"))

# åˆå§‹åŒ–æ•°æ®åº“
def init_db():
    conn = sqlite3.connect('database.db')
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS ai_decisions
                 (id INTEGER PRIMARY KEY, 
                  user_input TEXT,
                  intent TEXT,
                  action TEXT,
                  result TEXT,
                  timestamp TEXT)''')
    conn.commit()
    conn.close()

init_db()

# æ ¸å¿ƒæŠ€èƒ½åº“ï¼ˆç¡¬ç¼–ç å¼€å§‹ï¼Œå¤Ÿç”¨å°±è¡Œï¼‰
SKILLS = {
    "get_order": lambda order_id: {
        "order_id": order_id,
        "status": "å·²å‘è´§",
        "tracking": "SF1234567890"
    },
    "query_inventory": lambda product_id: {
        "product_id": product_id,
        "stock": 100,
        "warehouse": "æ·±åœ³ä»“"
    },
    "send_email": lambda to, content: {
        "sent": True,
        "to": to,
        "timestamp": datetime.now().isoformat()
    }
}

@app.post("/chat")
async def chat(user_input: str):
    """æ ¸å¿ƒå¯¹è¯æ¥å£"""
    try:
        # Step 1: ç”¨Claudeè¯†åˆ«æ„å›¾å¹¶ç”Ÿæˆæ‰§è¡Œè®¡åˆ’
        response = client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=1000,
            messages=[{
                "role": "user",
                "content": f"""ä½ æ˜¯ä¼ä¸šAIåŠ©æ‰‹ã€‚ç”¨æˆ·è¯´ï¼š"{user_input}"

å¯ç”¨æŠ€èƒ½ï¼š
- get_order(order_id): æŸ¥è¯¢è®¢å•
- query_inventory(product_id): æŸ¥åº“å­˜  
- send_email(to, content): å‘é‚®ä»¶

è¯·åˆ†ææ„å›¾ï¼Œè¿”å›JSONæ ¼å¼æ‰§è¡Œè®¡åˆ’ï¼š
{{
  "intent": "æ„å›¾åç§°",
  "skill": "æŠ€èƒ½åç§°",
  "params": {{"å‚æ•°": "å€¼"}},
  "response_template": "å›å¤æ¨¡æ¿"
}}"""
            }]
        )
        
        # Step 2: è§£æAIè¿”å›çš„è®¡åˆ’
        import json
        plan_text = response.content[0].text
        # æå–JSONï¼ˆç®€å•å¤„ç†ï¼‰
        plan_text = plan_text.replace("```json", "").replace("```", "").strip()
        plan = json.loads(plan_text)
        
        # Step 3: æ‰§è¡ŒæŠ€èƒ½
        skill_name = plan["skill"]
        params = plan["params"]
        
        if skill_name in SKILLS:
            result = SKILLS[skill_name](**params)
        else:
            result = {"error": "æŠ€èƒ½ä¸å­˜åœ¨"}
        
        # Step 4: ç”Ÿæˆç”¨æˆ·å“åº”
        final_response = client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=500,
            messages=[{
                "role": "user",
                "content": f"""æ‰§è¡Œç»“æœï¼š{json.dumps(result, ensure_ascii=False)}
                
ä½¿ç”¨è¿™ä¸ªæ¨¡æ¿å›å¤ç”¨æˆ·ï¼š{plan['response_template']}"""
            }]
        )
        
        user_message = final_response.content[0].text
        
        # Step 5: è®°å½•å†³ç­–
        conn = sqlite3.connect('database.db')
        c = conn.cursor()
        c.execute("""INSERT INTO ai_decisions 
                     (user_input, intent, action, result, timestamp) 
                     VALUES (?, ?, ?, ?, ?)""",
                  (user_input, plan["intent"], skill_name, 
                   json.dumps(result), datetime.now().isoformat()))
        conn.commit()
        conn.close()
        
        return {
            "success": True,
            "message": user_message,
            "debug": {
                "intent": plan["intent"],
                "skill": skill_name,
                "result": result
            }
        }
        
    except Exception as e:
        return {"success": False, "error": str(e)}

@app.get("/")
def root():
    return {"status": "AI Assistant Running", "version": "0.1"}

# è¿è¡Œï¼šuvicorn app.main:app --reload
```

**Day 2å®æˆ˜ä»£ç  - Streamlit UI**ï¼š

```python
# ui/app.py - è¶…ç®€å•èŠå¤©ç•Œé¢
import streamlit as st
import requests
import json

st.set_page_config(page_title="AIä¸šåŠ¡åŠ©æ‰‹", page_icon="ğŸ¤–")

st.title("ğŸ¤– ä¼ä¸šAIä¸šåŠ¡åŠ©æ‰‹")
st.caption("15å¤©æé€Ÿç‰ˆ v0.1")

# åˆå§‹åŒ–ä¼šè¯
if "messages" not in st.session_state:
    st.session_state.messages = []

# æ˜¾ç¤ºå†å²æ¶ˆæ¯
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])

# ç”¨æˆ·è¾“å…¥
if prompt := st.chat_input("è¾“å…¥æ‚¨çš„éœ€æ±‚..."):
    # æ˜¾ç¤ºç”¨æˆ·æ¶ˆæ¯
    st.session_state.messages.append({"role": "user", "content": prompt})
    with st.chat_message("user"):
        st.markdown(prompt)
    
    # è°ƒç”¨åç«¯API
    with st.chat_message("assistant"):
        with st.spinner("AIæ­£åœ¨æ€è€ƒ..."):
            try:
                response = requests.post(
                    "http://localhost:8000/chat",
                    params={"user_input": prompt}
                )
                data = response.json()
                
                if data["success"]:
                    st.markdown(data["message"])
                    
                    # æ˜¾ç¤ºè°ƒè¯•ä¿¡æ¯
                    with st.expander("ğŸ” æŸ¥çœ‹æ‰§è¡Œè¯¦æƒ…"):
                        st.json(data["debug"])
                    
                    st.session_state.messages.append({
                        "role": "assistant", 
                        "content": data["message"]
                    })
                else:
                    st.error(f"é”™è¯¯ï¼š{data['error']}")
            except Exception as e:
                st.error(f"è¿æ¥å¤±è´¥ï¼š{e}")

# ä¾§è¾¹æ 
with st.sidebar:
    st.header("âš™ï¸ ç³»ç»ŸçŠ¶æ€")
    
    # æ£€æŸ¥åç«¯çŠ¶æ€
    try:
        health = requests.get("http://localhost:8000/")
        if health.status_code == 200:
            st.success("âœ… åç«¯è¿è¡Œæ­£å¸¸")
        else:
            st.error("âŒ åç«¯å¼‚å¸¸")
    except:
        st.error("âŒ åç«¯æœªè¿æ¥")
    
    st.divider()
    
    # å¿«æ·æµ‹è¯•
    st.header("ğŸš€ å¿«é€Ÿæµ‹è¯•")
    if st.button("æŸ¥è¯¢è®¢å•12345"):
        st.session_state.messages.append({
            "role": "user",
            "content": "æŸ¥è¯¢è®¢å•12345çš„çŠ¶æ€"
        })
        st.rerun()
    
    if st.button("æŸ¥è¯¢äº§å“Aåº“å­˜"):
        st.session_state.messages.append({
            "role": "user",
            "content": "äº§å“Aè¿˜æœ‰å¤šå°‘åº“å­˜ï¼Ÿ"
        })
        st.rerun()

# è¿è¡Œï¼šstreamlit run ui/app.py
```

### Day 3-5: 3ä¸ªæ ¸å¿ƒSkillå®ç°

**ä¸è¦å¤æ‚çš„å¾®æœåŠ¡ï¼ç›´æ¥å†™å‡½æ•°ï¼š**

```python
# app/skills.py - çœŸå®Skillå®ç°ï¼ˆæ¥å…¥çœŸå®ç³»ç»Ÿï¼‰

import requests
from typing import Dict, Any

class OrderSkill:
    """è®¢å•æŠ€èƒ½"""
    def __init__(self, api_base_url: str):
        self.api_base = api_base_url
    
    def get_order(self, order_id: str) -> Dict[str, Any]:
        """æŸ¥è¯¢è®¢å•è¯¦æƒ…"""
        try:
            # è°ƒç”¨ä½ ä»¬å†…éƒ¨è®¢å•ç³»ç»ŸAPI
            response = requests.get(
                f"{self.api_base}/orders/{order_id}",
                headers={"Authorization": f"Bearer {os.getenv('ORDER_API_KEY')}"},
                timeout=5
            )
            response.raise_for_status()
            return response.json()
        except Exception as e:
            return {"error": str(e)}
    
    def update_order_status(self, order_id: str, status: str) -> Dict[str, Any]:
        """æ›´æ–°è®¢å•çŠ¶æ€"""
        try:
            response = requests.put(
                f"{self.api_base}/orders/{order_id}/status",
                json={"status": status},
                headers={"Authorization": f"Bearer {os.getenv('ORDER_API_KEY')}"},
                timeout=5
            )
            response.raise_for_status()
            return {"success": True, "order_id": order_id, "new_status": status}
        except Exception as e:
            return {"error": str(e)}

class InventorySkill:
    """åº“å­˜æŠ€èƒ½"""
    def __init__(self, api_base_url: str):
        self.api_base = api_base_url
    
    def query_inventory(self, product_id: str) -> Dict[str, Any]:
        """æŸ¥è¯¢åº“å­˜"""
        try:
            response = requests.get(
                f"{self.api_base}/inventory/{product_id}",
                timeout=5
            )
            response.raise_for_status()
            return response.json()
        except Exception as e:
            return {"error": str(e)}

class NotificationSkill:
    """é€šçŸ¥æŠ€èƒ½"""
    def send_email(self, to: str, subject: str, content: str) -> Dict[str, Any]:
        """å‘é€é‚®ä»¶"""
        # ä½¿ç”¨SendGrid/é˜¿é‡Œäº‘é‚®ä»¶æœåŠ¡
        import sendgrid
        from sendgrid.helpers.mail import Mail
        
        sg = sendgrid.SendGridAPIClient(api_key=os.getenv('SENDGRID_API_KEY'))
        message = Mail(
            from_email='noreply@company.com',
            to_emails=to,
            subject=subject,
            html_content=content
        )
        
        try:
            response = sg.send(message)
            return {"success": True, "status_code": response.status_code}
        except Exception as e:
            return {"error": str(e)}

# åœ¨main.pyä¸­æ³¨å†Œè¿™äº›Skill
```

### Day 6-8: Orchestratorå¢å¼º

```python
# app/orchestrator.py - AIç¼–æ’å™¨ï¼ˆæ ¸å¿ƒå¤§è„‘ï¼‰

from anthropic import Anthropic
import json
from typing import Dict, Any, List

class AIOrchestrator:
    """AIç¼–æ’å™¨ - ç³»ç»Ÿå¤§è„‘"""
    
    def __init__(self, api_key: str):
        self.client = Anthropic(api_key=api_key)
        self.skills = {}  # æ³¨å†Œçš„æŠ€èƒ½
        self.conversation_history = []  # å¯¹è¯å†å²ï¼ˆç®€åŒ–ç‰ˆï¼‰
    
    def register_skill(self, name: str, func: callable, description: str):
        """æ³¨å†ŒæŠ€èƒ½"""
        self.skills[name] = {
            "function": func,
            "description": description
        }
    
    def execute(self, user_input: str, user_id: str = "default") -> Dict[str, Any]:
        """æ‰§è¡Œç”¨æˆ·è¯·æ±‚"""
        
        # 1. æ„å»ºæŠ€èƒ½æ¸…å•ï¼ˆç»™AIçœ‹ï¼‰
        skills_desc = "\n".join([
            f"- {name}: {info['description']}" 
            for name, info in self.skills.items()
        ])
        
        # 2. è®©AIç”Ÿæˆæ‰§è¡Œè®¡åˆ’
        plan_prompt = f"""ä½ æ˜¯ä¼ä¸šAIåŠ©æ‰‹ã€‚ç”¨æˆ·è¯·æ±‚ï¼š"{user_input}"

å¯ç”¨æŠ€èƒ½ï¼š
{skills_desc}

è¯·åˆ†ææ„å›¾å¹¶ç”Ÿæˆæ‰§è¡Œè®¡åˆ’ï¼Œä¸¥æ ¼æŒ‰æ­¤JSONæ ¼å¼è¿”å›ï¼š
{{
  "intent": "ç”¨æˆ·æ„å›¾ç®€è¿°",
  "steps": [
    {{
      "skill": "æŠ€èƒ½åç§°",
      "params": {{"å‚æ•°å": "å‚æ•°å€¼"}},
      "description": "æ­¥éª¤è¯´æ˜"
    }}
  ],
  "response_template": "ç”¨{{{{result}}}}å ä½ç¬¦çš„å›å¤æ¨¡æ¿"
}}

åªè¿”å›JSONï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚"""
        
        try:
            response = self.client.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=2000,
                messages=[{"role": "user", "content": plan_prompt}]
            )
            
            # è§£æè®¡åˆ’
            plan_text = response.content[0].text.strip()
            plan_text = plan_text.replace("```json", "").replace("```", "").strip()
            plan = json.loads(plan_text)
            
            # 3. æ‰§è¡Œè®¡åˆ’ä¸­çš„æ¯ä¸ªæ­¥éª¤
            results = []
            for step in plan["steps"]:
                skill_name = step["skill"]
                params = step["params"]
                
                if skill_name in self.skills:
                    skill_func = self.skills[skill_name]["function"]
                    result = skill_func(**params)
                    results.append({
                        "skill": skill_name,
                        "params": params,
                        "result": result
                    })
                else:
                    results.append({
                        "skill": skill_name,
                        "error": "æŠ€èƒ½ä¸å­˜åœ¨"
                    })
            
            # 4. ç”Ÿæˆæœ€ç»ˆå›å¤
            final_prompt = f"""æ‰§è¡Œç»“æœï¼š
{json.dumps(results, ensure_ascii=False, indent=2)}

è¯·ç”¨è‡ªç„¶ã€å‹å¥½çš„è¯­è¨€å›å¤ç”¨æˆ·ï¼Œå‚è€ƒæ¨¡æ¿ï¼š
{plan['response_template']}

ç›´æ¥ç»™å‡ºå›å¤å†…å®¹ï¼Œä¸è¦JSONæ ¼å¼ã€‚"""
            
            final_response = self.client.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=1000,
                messages=[{"role": "user", "content": final_prompt}]
            )
            
            user_message = final_response.content[0].text
            
            return {
                "success": True,
                "message": user_message,
                "intent": plan["intent"],
                "steps_executed": len(results),
                "details": results
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "message": "æŠ±æ­‰ï¼Œå¤„ç†è¯·æ±‚æ—¶å‡ºé”™äº†ã€‚"
            }
```

### Day 9-12: æ•°æ®è®°å½•ä¸åŸºç¡€ç›‘æ§

```python
# app/models.py - æ•°æ®æ¨¡å‹ï¼ˆSQLAlchemyï¼‰

from sqlalchemy import create_engine, Column, Integer, String, Text, Float, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime

Base = declarative_base()

class AIDecision(Base):
    """AIå†³ç­–è®°å½•"""
    __tablename__ = 'ai_decisions'
    
    id = Column(Integer, primary_key=True)
    user_id = Column(String(64))
    user_input = Column(Text)
    intent = Column(String(128))
    skills_used = Column(Text)  # JSONå­—ç¬¦ä¸²
    result = Column(Text)  # JSONå­—ç¬¦ä¸²
    success = Column(Integer)  # 1=æˆåŠŸ, 0=å¤±è´¥
    execution_time_ms = Column(Float)
    llm_cost = Column(Float)  # ç¾å…ƒ
    timestamp = Column(DateTime, default=datetime.now)
    
class SystemMetrics(Base):
    """ç³»ç»ŸæŒ‡æ ‡"""
    __tablename__ = 'metrics'
    
    id = Column(Integer, primary_key=True)
    metric_name = Column(String(64))
    metric_value = Column(Float)
    timestamp = Column(DateTime, default=datetime.now)

# åˆ›å»ºæ•°æ®åº“
engine = create_engine('sqlite:///database.db')
Base.metadata.create_all(engine)
Session = sessionmaker(bind=engine)
```

### Day 13-15: ç«¯åˆ°ç«¯æµ‹è¯• + éƒ¨ç½²

```bash
# Day 13-14: æµ‹è¯•
# ç¼–å†™æµ‹è¯•è„šæœ¬
python tests/test_e2e.py

# Day 15: ä¸€é”®éƒ¨ç½²ï¼ˆä½¿ç”¨Railwayï¼‰
# 1. æ³¨å†ŒRailwayè´¦å·ï¼ˆå…è´¹ï¼‰
# 2. è¿æ¥GitHubä»“åº“
# 3. è‡ªåŠ¨éƒ¨ç½²

# æˆ–ä½¿ç”¨Dockerï¼ˆå¤‡é€‰ï¼‰
docker build -t ai-assistant .
docker run -p 8000:8000 ai-assistant
```

**Day 15äº¤ä»˜ç‰©**ï¼š
- âœ… èƒ½æ¥æ”¶ç”¨æˆ·è¾“å…¥
- âœ… AIç†è§£æ„å›¾
- âœ… è°ƒç”¨è‡³å°‘2ä¸ªçœŸå®æŠ€èƒ½ï¼ˆè®¢å•æŸ¥è¯¢ã€åº“å­˜æŸ¥è¯¢ï¼‰
- âœ… è¿”å›ç»“æ„åŒ–ç»“æœ
- âœ… æ‰€æœ‰å†³ç­–è®°å½•åˆ°æ•°æ®åº“
- âœ… éƒ¨ç½²åˆ°å¯è®¿é—®çš„URL

---

## é˜¶æ®µ2: ç¬¬16-30å¤© - 3æ¡æ ¸å¿ƒæµç¨‹è„šæœ¬åŒ–

**ç›®æ ‡**: æŠŠ3ä¸ªæœ€å¸¸ç”¨çš„ä¸šåŠ¡æµç¨‹è‡ªåŠ¨åŒ–

### Day 16-17: SOPå¼•æ“ï¼ˆæç®€ç‰ˆï¼‰

```python
# app/sop_engine.py - SOPæ‰§è¡Œå¼•æ“

import yaml
from typing import Dict, Any

class SOPEngine:
    """SOPæ‰§è¡Œå¼•æ“"""
    
    def __init__(self, orchestrator: AIOrchestrator):
        self.orchestrator = orchestrator
        self.sops = {}
    
    def load_sop(self, sop_file: str):
        """åŠ è½½SOPé…ç½®"""
        with open(sop_file, 'r', encoding='utf-8') as f:
            sop = yaml.safe_load(f)
            self.sops[sop['id']] = sop
    
    def execute_sop(self, sop_id: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """æ‰§è¡ŒSOP"""
        if sop_id not in self.sops:
            return {"error": "SOPä¸å­˜åœ¨"}
        
        sop = self.sops[sop_id]
        results = []
        
        # æ‰§è¡ŒSOPä¸­çš„æ¯ä¸ªæ­¥éª¤
        for step in sop['steps']:
            step_type = step['type']
            
            if step_type == 'skill_call':
                # è°ƒç”¨æŠ€èƒ½
                skill_name = step['skill']
                params = self._resolve_params(step['params'], context)
                result = self.orchestrator.skills[skill_name]['function'](**params)
                context[step['output_var']] = result
                results.append(result)
            
            elif step_type == 'decision':
                # å†³ç­–é€»è¾‘
                condition = self._evaluate_condition(step['condition'], context)
                if condition:
                    # æ‰§è¡Œtrueåˆ†æ”¯
                    pass
                else:
                    # æ‰§è¡Œfalseåˆ†æ”¯
                    pass
        
        return {"success": True, "results": results}
    
    def _resolve_params(self, params: Dict, context: Dict) -> Dict:
        """è§£æå‚æ•°ï¼ˆæ”¯æŒ${å˜é‡}ï¼‰"""
        resolved = {}
        for key, value in params.items():
            if isinstance(value, str) and value.startswith("${"):
                var_name = value[2:-1]
                resolved[key] = context.get(var_name)
            else:
                resolved[key] = value
        return resolved
```

### Day 18-22: å¼€å‘3æ¡æ ¸å¿ƒSOP

**SOP 1: è®¢å•å»¶è¿Ÿå¤„ç†**

```yaml
# sops/order_delay.yaml
id: order_delay_handler
name: è®¢å•å»¶è¿Ÿè‡ªåŠ¨å¤„ç†
description: è‡ªåŠ¨æŸ¥è¯¢è®¢å•ã€ç‰©æµï¼Œå‘é€é“æ­‰é‚®ä»¶å’Œè¡¥å¿

triggers:
  - intent: "è®¢å•å»¶è¿ŸæŸ¥è¯¢"
  - keywords: ["å»¶è¿Ÿ", "æ²¡åˆ°", "ç‰©æµ"]

steps:
  - type: skill_call
    skill: get_order
    params:
      order_id: ${order_id}
    output_var: order
  
  - type: skill_call
    skill: query_logistics
    params:
      tracking_number: ${order.tracking_number}
    output_var: logistics
  
  - type: decision
    condition: logistics.status == 'delayed'
    true_branch:
      - type: skill_call
        skill: generate_apology
        params:
          order_id: ${order_id}
          reason: ${logistics.delay_reason}
        output_var: apology
      
      - type: skill_call
        skill: offer_compensation
        params:
          user_id: ${user_id}
          policy: standard_delay
        output_var: compensation
      
      - type: skill_call
        skill: send_email
        params:
          to: ${order.customer_email}
          subject: è®¢å•å»¶è¿Ÿé€šçŸ¥
          content: ${apology.content}
```

**SOP 2: åº“å­˜é¢„è­¦**

```yaml
# sops/inventory_alert.yaml
id: inventory_alert
name: åº“å­˜é¢„è­¦è‡ªåŠ¨å¤„ç†

triggers:
  - event: inventory_low
  - schedule: "0 9 * * *"  # æ¯å¤©9ç‚¹æ£€æŸ¥

steps:
  - type: skill_call
    skill: query_all_inventory
    output_var: inventory_list
  
  - type: decision
    condition: any(item.stock < item.threshold for item in inventory_list)
    true_branch:
      - type: skill_call
        skill: generate_restock_plan
        params:
          low_stock_items: ${low_stock_items}
        output_var: plan
      
      - type: skill_call
        skill: send_email
        params:
          to: "purchasing@company.com"
          subject: åº“å­˜é¢„è­¦
          content: ${plan.report}
```

**SOP 3: æ™ºèƒ½é€€æ¬¾**

```yaml
# sops/smart_refund.yaml
id: smart_refund
name: æ™ºèƒ½é€€æ¬¾å†³ç­–

steps:
  - type: skill_call
    skill: get_order
    params:
      order_id: ${order_id}
    output_var: order
  
  - type: skill_call
    skill: get_user_history
    params:
      user_id: ${user_id}
    output_var: history
  
  - type: ai_decision
    prompt: |
      è®¢å•é‡‘é¢ï¼š${order.amount}
      ç”¨æˆ·ç­‰çº§ï¼š${history.vip_level}
      é€€æ¬¾åŸå› ï¼š${reason}
      å†å²é€€æ¬¾æ¬¡æ•°ï¼š${history.refund_count}
      
      å†³ç­–æ˜¯å¦æ‰¹å‡†é€€æ¬¾ï¼Œè¿”å›JSONï¼š
      {"approve": true/false, "reason": "åŸå› "}
    output_var: decision
  
  - type: decision
    condition: decision.approve == true
    true_branch:
      - type: skill_call
        skill: process_refund
        params:
          order_id: ${order_id}
          amount: ${order.amount}
```

### Day 23-25: SOPä¸UIé›†æˆ

```python
# åœ¨Streamlit UIä¸­æ·»åŠ SOPè§¦å‘

# ui/app.py å¢åŠ 
st.sidebar.header("ğŸ“‹ å¿«é€ŸSOP")

if st.sidebar.button("ğŸšš å¤„ç†è®¢å•å»¶è¿Ÿ"):
    order_id = st.sidebar.text_input("è®¢å•å·")
    if order_id:
        # è°ƒç”¨SOP API
        response = requests.post(
            "http://localhost:8000/sop/execute",
            json={"sop_id": "order_delay_handler", "context": {"order_id": order_id}}
        )
        st.write(response.json())
```

### Day 26-30: ç›‘æ§çœ‹æ¿V1.0

```python
# ui/dashboard.py - ç›‘æ§çœ‹æ¿

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import requests

st.set_page_config(page_title="AIåŠ©æ‰‹ç›‘æ§çœ‹æ¿", layout="wide")

st.title("ğŸ“Š AIåŠ©æ‰‹ç›‘æ§çœ‹æ¿ V1.0")

# åˆ·æ–°æŒ‰é’®
col1, col2, col3 = st.columns([1, 1, 4])
with col1:
    if st.button("ğŸ”„ åˆ·æ–°æ•°æ®"):
        st.rerun()
with col2:
    auto_refresh = st.checkbox("è‡ªåŠ¨åˆ·æ–°ï¼ˆ30ç§’ï¼‰")

if auto_refresh:
    import time
    time.sleep(30)
    st.rerun()

# è·å–å®æ—¶æ•°æ®
try:
    metrics = requests.get("http://localhost:8000/metrics").json()
except:
    st.error("âŒ æ— æ³•è¿æ¥åç«¯")
    st.stop()

# === æ ¸å¿ƒæŒ‡æ ‡ ===
st.header("ğŸ“ˆ æ ¸å¿ƒæŒ‡æ ‡")
metric_cols = st.columns(4)

with metric_cols[0]:
    st.metric(
        label="ä»Šæ—¥å¤„ç†é‡",
        value=metrics.get("today_total", 0),
        delta=f"+{metrics.get('today_delta', 0)} vsæ˜¨å¤©"
    )

with metric_cols[1]:
    success_rate = metrics.get("success_rate", 0)
    st.metric(
        label="æˆåŠŸç‡",
        value=f"{success_rate:.1%}",
        delta=f"{metrics.get('success_rate_delta', 0):.1%}"
    )

with metric_cols[2]:
    st.metric(
        label="å¹³å‡å“åº”æ—¶é—´",
        value=f"{metrics.get('avg_response_ms', 0):.0f}ms",
        delta=f"{metrics.get('response_delta', 0):.0f}ms"
    )

with metric_cols[3]:
    st.metric(
        label="ä»Šæ—¥æˆæœ¬",
        value=f"${metrics.get('today_cost', 0):.2f}",
        delta=f"${metrics.get('cost_delta', 0):.2f}"
    )

st.divider()

# === å®æ—¶å‘Šè­¦ ===
st.header("ğŸš¨ å®æ—¶å‘Šè­¦")
alerts = metrics.get("alerts", [])

if alerts:
    for alert in alerts:
        if alert["level"] == "critical":
            st.error(f"ğŸ”´ {alert['message']}")
        elif alert["level"] == "warning":
            st.warning(f"ğŸŸ¡ {alert['message']}")
else:
    st.success("âœ… ç³»ç»Ÿè¿è¡Œæ­£å¸¸ï¼Œæ— å‘Šè­¦")

st.divider()

# === è¶‹åŠ¿å›¾è¡¨ ===
col_left, col_right = st.columns(2)

with col_left:
    st.subheader("ğŸ“Š 24å°æ—¶å¤„ç†é‡è¶‹åŠ¿")
    # è·å–å†å²æ•°æ®
    history = pd.DataFrame(metrics.get("hourly_stats", []))
    if not history.empty:
        fig = px.line(
            history, 
            x='hour', 
            y='count',
            title='æ¯å°æ—¶å¤„ç†é‡'
        )
        st.plotly_chart(fig, use_container_width=True)

with col_right:
    st.subheader("ğŸ¯ æ„å›¾åˆ†å¸ƒ")
    intent_data = pd.DataFrame(metrics.get("intent_distribution", []))
    if not intent_data.empty:
        fig = px.pie(
            intent_data,
            values='count',
            names='intent',
            title='æ„å›¾ç±»å‹åˆ†å¸ƒ'
        )
        st.plotly_chart(fig, use_container_width=True)

st.divider()

# === SOPæ‰§è¡Œç»Ÿè®¡ ===
st.header("ğŸ“‹ SOPæ‰§è¡Œç»Ÿè®¡")
sop_stats = pd.DataFrame(metrics.get("sop_stats", []))

if not sop_stats.empty:
    st.dataframe(
        sop_stats,
        column_config={
            "sop_name": "SOPåç§°",
            "total": "æ‰§è¡Œæ¬¡æ•°",
            "success": "æˆåŠŸæ¬¡æ•°",
            "success_rate": st.column_config.ProgressColumn(
                "æˆåŠŸç‡",
                format="%.1f%%",
                min_value=0,
                max_value=100,
            ),
            "avg_time": "å¹³å‡è€—æ—¶(ms)"
        },
        hide_index=True,
        use_container_width=True
    )

st.divider()

# === æœ€è¿‘å†³ç­–æ—¥å¿— ===
st.header("ğŸ“ æœ€è¿‘å†³ç­–æ—¥å¿—")
logs = pd.DataFrame(metrics.get("recent_logs", []))

if not logs.empty:
    st.dataframe(
        logs,
        column_config={
            "timestamp": "æ—¶é—´",
            "user_input": "ç”¨æˆ·è¾“å…¥",
            "intent": "æ„å›¾",
            "result": "ç»“æœ",
            "execution_time": "è€—æ—¶(ms)"
        },
        hide_index=True,
        use_container_width=True
    )

# è¿è¡Œï¼šstreamlit run ui/dashboard.py --server.port 8501
```

**Day 30äº¤ä»˜ç‰©**ï¼š
- âœ… 3æ¡SOPè„šæœ¬åŒ–å¹¶æµ‹è¯•é€šè¿‡
- âœ… ç›‘æ§çœ‹æ¿ä¸Šçº¿ï¼Œæ”¯æŒå®æ—¶åˆ·æ–°
- âœ… å¼‚å¸¸å‘Šè­¦åŠŸèƒ½ï¼ˆæˆåŠŸç‡<90%ã€å“åº”æ—¶é—´>2sï¼‰
- âœ… æ ¸å¿ƒæŒ‡æ ‡å¯è§†åŒ–

---

## é˜¶æ®µ3: ç¬¬31-45å¤© - MVPå®Œå–„ä¸æµ‹è¯•è´¦å·æ¥å…¥

### Day 31-35: ç”¨æˆ·ç³»ç»Ÿä¸æƒé™

```python
# app/auth.py - æç®€è®¤è¯

from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt
from datetime import datetime, timedelta

SECRET_KEY = "your-secret-key"  # ç”Ÿäº§ç¯å¢ƒç”¨ç¯å¢ƒå˜é‡
ALGORITHM = "HS256"

security = HTTPBearer()

# æµ‹è¯•è´¦å·ï¼ˆç¡¬ç¼–ç ï¼Œå¤Ÿç”¨ï¼‰
TEST_USERS = {
    "test001": {"password": "test123", "role": "viewer", "name": "æµ‹è¯•è´¦å·1"},
    "test002": {"password": "test456", "role": "admin", "name": "æµ‹è¯•è´¦å·2"},
}

def create_token(user_id: str) -> str:
    """ç”ŸæˆJWT token"""
    expire = datetime.utcnow() + timedelta(days=7)
    payload = {"sub": user_id, "exp": expire}
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """éªŒè¯token"""
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        user_id = payload.get("sub")
        if user_id not in TEST_USERS:
            raise HTTPException(status_code=401, detail="ç”¨æˆ·ä¸å­˜åœ¨")
        return user_id
    except:
        raise HTTPException(status_code=401, detail="Tokenæ— æ•ˆ")

# åœ¨main.pyä¸­æ·»åŠ ç™»å½•æ¥å£
@app.post("/login")
def login(user_id: str, password: str):
    if user_id in TEST_USERS and TEST_USERS[user_id]["password"] == password:
        token = create_token(user_id)
        return {"token": token, "user": TEST_USERS[user_id]}
    raise HTTPException(status_code=401, detail="ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯")

# ä¿æŠ¤æ ¸å¿ƒæ¥å£
@app.post("/chat")
async def chat(user_input: str, user_id: str = Depends(verify_token)):
    # ... åŸæœ‰é€»è¾‘
```

### Day 36-40: å¤šè½®å¯¹è¯ä¸ä¸Šä¸‹æ–‡

```python
# app/session.py - ä¼šè¯ç®¡ç†ï¼ˆRediså¤ªé‡ï¼Œç”¨å†…å­˜+å®šæœŸè½ç›˜ï¼‰

from typing import Dict, List
import json
from datetime import datetime, timedelta

class SessionManager:
    """ä¼šè¯ç®¡ç†å™¨"""
    
    def __init__(self):
        self.sessions: Dict[str, Session] = {}
    
    def get_or_create(self, user_id: str) -> 'Session':
        """è·å–æˆ–åˆ›å»ºä¼šè¯"""
        if user_id not in self.sessions:
            self.sessions[user_id] = Session(user_id)
        return self.sessions[user_id]
    
    def cleanup_expired(self):
        """æ¸…ç†è¿‡æœŸä¼šè¯"""
        now = datetime.now()
        expired = [
            uid for uid, session in self.sessions.items()
            if now - session.last_active > timedelta(minutes=30)
        ]
        for uid in expired:
            del self.sessions[uid]

class Session:
    """ä¼šè¯å¯¹è±¡"""
    
    def __init__(self, user_id: str):
        self.user_id = user_id
        self.history: List[Dict] = []
        self.context: Dict = {}
        self.last_active = datetime.now()
    
    def add_message(self, role: str, content: str):
        """æ·»åŠ æ¶ˆæ¯"""
        self.history.append({
            "role": role,
            "content": content,
            "timestamp": datetime.now().isoformat()
        })
        self.last_active = datetime.now()
        
        # åªä¿ç•™æœ€è¿‘10è½®
        if len(self.history) > 20:
            self.history = self.history[-20:]
    
    def get_context_summary(self) -> str:
        """è·å–ä¸Šä¸‹æ–‡æ‘˜è¦"""
        if len(self.history) < 2:
            return ""
        
        recent = self.history[-6:]  # æœ€è¿‘3è½®å¯¹è¯
        summary = "\n".join([
            f"{msg['role']}: {msg['content']}" 
            for msg in recent
        ])
        return f"æœ€è¿‘å¯¹è¯ï¼š\n{summary}"

# åœ¨orchestratorä¸­ä½¿ç”¨
def execute(self, user_input: str, session: Session) -> Dict:
    # æ·»åŠ ä¸Šä¸‹æ–‡
    context_summary = session.get_context_summary()
    enhanced_prompt = f"{context_summary}\n\nå½“å‰ç”¨æˆ·è¾“å…¥ï¼š{user_input}"
    
    # ... å…¶ä½™é€»è¾‘
    
    # è®°å½•å¯¹è¯
    session.add_message("user", user_input)
    session.add_message("assistant", result_message)
```

### Day 41-43: é”™è¯¯å¤„ç†ä¸é‡è¯•

```python
# app/retry.py - é‡è¯•æœºåˆ¶

from functools import wraps
import time
import logging

def retry(max_attempts=3, delay=1, backoff=2):
    """é‡è¯•è£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            attempts = 0
            current_delay = delay
            
            while attempts < max_attempts:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    attempts += 1
                    if attempts >= max_attempts:
                        logging.error(f"Failed after {max_attempts} attempts: {e}")
                        raise
                    
                    logging.warning(f"Attempt {attempts} failed, retrying in {current_delay}s...")
                    time.sleep(current_delay)
                    current_delay *= backoff
        
        return wrapper
    return decorator

# ä½¿ç”¨ç¤ºä¾‹
@retry(max_attempts=3, delay=1)
def call_external_api(url: str):
    response = requests.get(url, timeout=5)
    response.raise_for_status()
    return response.json()
```

### Day 44-45: æµ‹è¯•ä¸æ–‡æ¡£

```python
# tests/test_e2e.py - ç«¯åˆ°ç«¯æµ‹è¯•

import pytest
import requests

BASE_URL = "http://localhost:8000"

def test_login():
    """æµ‹è¯•ç™»å½•"""
    response = requests.post(
        f"{BASE_URL}/login",
        json={"user_id": "test001", "password": "test123"}
    )
    assert response.status_code == 200
    assert "token" in response.json()

def test_chat_order_query():
    """æµ‹è¯•è®¢å•æŸ¥è¯¢å¯¹è¯"""
    # å…ˆç™»å½•
    login_resp = requests.post(
        f"{BASE_URL}/login",
        json={"user_id": "test001", "password": "test123"}
    )
    token = login_resp.json()["token"]
    
    # å‘èµ·å¯¹è¯
    response = requests.post(
        f"{BASE_URL}/chat",
        params={"user_input": "æŸ¥è¯¢è®¢å•12345çš„çŠ¶æ€"},
        headers={"Authorization": f"Bearer {token}"}
    )
    
    assert response.status_code == 200
    data = response.json()
    assert data["success"] == True
    assert "è®¢å•" in data["message"]

def test_sop_execution():
    """æµ‹è¯•SOPæ‰§è¡Œ"""
    login_resp = requests.post(
        f"{BASE_URL}/login",
        json={"user_id": "test002", "password": "test456"}
    )
    token = login_resp.json()["token"]
    
    response = requests.post(
        f"{BASE_URL}/sop/execute",
        json={
            "sop_id": "order_delay_handler",
            "context": {"order_id": "12345", "user_id": "test001"}
        },
        headers={"Authorization": f"Bearer {token}"}
    )
    
    assert response.status_code == 200

# è¿è¡Œï¼špytest tests/test_e2e.py -v
```

**Day 45äº¤ä»˜ç‰©**ï¼š
- âœ… æµ‹è¯•è´¦å·ç³»ç»Ÿï¼ˆè‡³å°‘2ä¸ªæµ‹è¯•è´¦å·ï¼‰
- âœ… å¤šè½®å¯¹è¯æ”¯æŒ
- âœ… é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
- âœ… å®Œæ•´çš„E2Eæµ‹è¯•
- âœ… éƒ¨ç½²åˆ°æµ‹è¯•ç¯å¢ƒ
- âœ… ç”¨æˆ·æ‰‹å†Œï¼ˆ1é¡µçº¸ï¼‰

---

## æŠ€æœ¯æ ˆæ€»ç»“ï¼ˆæç®€ç‰ˆï¼‰

| ç»„ä»¶ | æŠ€æœ¯é€‰æ‹© | ç†ç”± |
|-----|---------|------|
| åç«¯æ¡†æ¶ | FastAPI | æœ€å¿«çš„Python Webæ¡†æ¶ |
| å‰ç«¯UI | Streamlit | é›¶å‰ç«¯ç»éªŒä¹Ÿèƒ½åšç•Œé¢ |
| æ•°æ®åº“ | SQLite â†’ PostgreSQL | å¼€å‘ç”¨SQLiteï¼Œç”Ÿäº§æ¢PostgreSQL |
| LLM | Claude API | ç›´æ¥è°ƒç”¨ï¼Œæ— éœ€éƒ¨ç½² |
| éƒ¨ç½² | Railway/Render | å…è´¹æ‰˜ç®¡ï¼Œè‡ªåŠ¨éƒ¨ç½² |
| ç›‘æ§ | è‡ªå»ºï¼ˆStreamlitï¼‰ | çœé’±ï¼Œå¤Ÿç”¨ |
| è®¤è¯ | JWT | è½»é‡çº§ï¼Œæ ‡å‡†æ–¹æ¡ˆ |

---

## æ—¶é—´çº¿ä¸æ£€æŸ¥ç‚¹

```
Day 1-2   â”‚ ç¯å¢ƒæ­å»º + éª¨æ¶ä»£ç 
Day 3-5   â”‚ æ ¸å¿ƒSkillå®ç°
Day 6-8   â”‚ Orchestratorå¢å¼º
Day 9-12  â”‚ æ•°æ®è®°å½• + åŸºç¡€ç›‘æ§
Day 13-15 â”‚ ç«¯åˆ°ç«¯æµ‹è¯• + éƒ¨ç½²
          â”‚ âœ… æ£€æŸ¥ç‚¹1ï¼šå±•ç¤ºç»™è€æ¿
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Day 16-17 â”‚ SOPå¼•æ“å®ç°
Day 18-22 â”‚ 3æ¡SOPå¼€å‘
Day 23-25 â”‚ SOPä¸UIé›†æˆ
Day 26-30 â”‚ ç›‘æ§çœ‹æ¿V1.0
          â”‚ âœ… æ£€æŸ¥ç‚¹2ï¼š3æ¡æµç¨‹æ¼”ç¤º
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Day 31-35 â”‚ ç”¨æˆ·ç³»ç»Ÿ + æƒé™
Day 36-40 â”‚ å¤šè½®å¯¹è¯ + ä¸Šä¸‹æ–‡
Day 41-43 â”‚ é”™è¯¯å¤„ç† + é‡è¯•
Day 44-45 â”‚ æµ‹è¯• + æ–‡æ¡£
          â”‚ âœ… æ£€æŸ¥ç‚¹3ï¼šMVPéªŒæ”¶
```

---

## å…³é”®æˆåŠŸå› ç´ 

### å¿…é¡»åšå¯¹çš„3ä»¶äº‹ï¼š

1. **Day 1-2ç»å¯¹ä¸èƒ½æ‹–**
   - ç¯å¢ƒä¸€æ¬¡æå®š
   - ç”¨æœ€ç†Ÿæ‚‰çš„æŠ€æœ¯æ ˆ
   - åˆ«æƒ³ç€æ¢æŠ€æœ¯

2. **ä¸“æ³¨æ ¸å¿ƒä»·å€¼**
   - åªåš3ä¸ªSkillï¼ˆè®¢å•ã€åº“å­˜ã€é€šçŸ¥ï¼‰
   - åªåš3æ¡SOP
   - å…¶ä»–åŠŸèƒ½å…¨éƒ¨ç æ‰

3. **æ¯å‘¨äº”ç»™è€æ¿çœ‹è¿›å±•**
   - Week 2: æ¼”ç¤ºç«¯åˆ°ç«¯æµç¨‹
   - Week 4: æ¼”ç¤º3æ¡SOP
   - Week 6: æ¼”ç¤ºå®Œæ•´MVP

### å¯ä»¥æš‚æ—¶ä¸åšçš„ï¼š

- âŒ å¾®æœåŠ¡æ¶æ„
- âŒ å¤æ‚çš„æƒé™ç³»ç»Ÿ
- âŒ å®Œç¾çš„UIè®¾è®¡
- âŒ è¯¦ç»†çš„æ—¥å¿—åˆ†æ
- âŒ é«˜å¯ç”¨éƒ¨ç½²
- âŒ æ€§èƒ½ä¼˜åŒ–
- âŒ å•å…ƒæµ‹è¯•å…¨è¦†ç›–

è¿™äº›ç­‰MVPè·‘é€šåï¼Œæœ‰æ—¶é—´å†è¡¥ï¼

---

## åº”æ€¥é¢„æ¡ˆ

### å¦‚æœè¿›åº¦è½åæ€ä¹ˆåŠï¼Ÿ

| é—®é¢˜ | è§£å†³æ–¹æ¡ˆ |
|-----|---------|
| Day 5è¿˜æ²¡è·‘é€šç«¯åˆ°ç«¯ | ç”¨Mockæ•°æ®ï¼Œå…ˆæŠŠæµç¨‹èµ°é€š |
| LLMå“åº”å¤ªæ…¢ | åŠ ç¼“å­˜ï¼Œç›¸ä¼¼é—®é¢˜ç›´æ¥è¿”å› |
| Skillå¯¹æ¥å›°éš¾ | å…ˆMockï¼Œæ ‡è®°TODOï¼Œåç»­è¡¥ |
| çœ‹æ¿åšä¸å‡ºæ¥ | ç”¨Excelæ‰‹åŠ¨æ›´æ–°ä¹Ÿè¡Œ |
| æµ‹è¯•è´¦å·æ¥ä¸åŠ | å»æ‰è®¤è¯ï¼Œç›´æ¥å¼€æ”¾ä½¿ç”¨ |

### æ•‘å‘½å·¥å…·æ¸…å•ï¼š

- **ChatGPT/Claude**: å¡ä½äº†å°±é—®AI
- **GitHub Copilot**: ä»£ç è‡ªåŠ¨è¡¥å…¨
- **Cursor**: AIè¾…åŠ©ç¼–ç¨‹
- **Streamlit Docs**: ç•Œé¢é—®é¢˜çœ‹æ–‡æ¡£
- **FastAPI Docs**: APIé—®é¢˜çœ‹å®˜æ–¹ä¾‹å­

---

## æœ€åçš„å»ºè®®

### ç»™ä½ çš„3ä¸ªé”¦å›Šï¼š

**é”¦å›Š1 - æ—¶é—´ç®¡ç†**ï¼š
- ä¸Šåˆå†™ä»£ç ï¼ˆæ€è·¯æœ€æ¸…æ™°ï¼‰
- ä¸‹åˆè°ƒè¯•å’Œæµ‹è¯•
- æ™šä¸Šå†™æ–‡æ¡£å’Œå‡†å¤‡æ¼”ç¤º
- å‘¨æœ«ä¼‘æ¯ï¼ˆä¸ç„¶æ’‘ä¸ä½45å¤©ï¼‰

**é”¦å›Š2 - å’Œè€æ¿æ²Ÿé€š**ï¼š
- æ¯å‘¨äº”ä¸‹åˆ4ç‚¹ï¼Œå›ºå®šæ±‡æŠ¥
- å‡†å¤‡3åˆ†é’Ÿæ¼”ç¤ºè§†é¢‘
- æå‰è¯´æ˜é£é™©å’Œä¾èµ–
- è¦èµ„æºæ—¶ç›´æ¥è¯´ï¼ˆæ¯”å¦‚éœ€è¦API keyï¼‰

**é”¦å›Š3 - ä¿æŒä¿¡å¿ƒ**ï¼š
- Day 15å¯èƒ½å¾ˆç²—ç³™ï¼Œ**ä½†èƒ½è·‘é€šå°±æ˜¯èƒœåˆ©**
- Day 30åŠŸèƒ½ä¸å®Œç¾ï¼Œ**ä½†æœ‰3ä¸ªæ¡ˆä¾‹å°±å¤Ÿ**
- Day 45ä¸æ˜¯æœ€ç»ˆç‰ˆï¼Œ**ä½†è¯æ˜äº†å¯è¡Œæ€§**

---

**è®°ä½ï¼šå®Œæˆæ¯”å®Œç¾æ›´é‡è¦ï¼å…ˆåšå‡ºæ¥ï¼Œå†ä¼˜åŒ–ã€‚**

**ä½ èƒ½è¡Œçš„ï¼ğŸ’ª**
