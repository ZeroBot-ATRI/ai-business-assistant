# 企业AI助手 - 15天极速启动方案（单人作战版）

## 战略思路：砍掉80%，保留20%核心价值

**核心原则**：
- ❌ 不做微服务，单体应用快速启动
- ❌ 不做复杂架构，能用现成工具绝不自己写
- ❌ 不做完美，先跑通再优化
- ✅ 使用最成熟的框架和工具
- ✅ 云服务能解决的不自建
- ✅ 功能能砍则砍，专注核心流程

---

## 阶段1: 15天极限冲刺 - 跑通端到端

**目标**: 证明技术可行性，展示给老板看

### Day 1-2: 环境速配 (关键！)

```bash
# 技术栈选择：最快上手的组合
1. 后端：FastAPI (Python) - 最快的API框架
2. 前端：Streamlit - 零前端经验也能做UI
3. 数据库：SQLite - 开发阶段够用
4. LLM：Claude API - 直接调用，无需部署
5. 部署：Railway/Render - 免费托管，一键部署

# Day 1上午：本地环境
pip install fastapi uvicorn anthropic sqlalchemy streamlit pydantic

# Day 1下午：项目结构（超简化版）
/ai-assistant
  /app
    main.py          # FastAPI主程序（200行搞定）
    models.py        # 数据模型
    orchestrator.py  # AI编排器（核心）
    skills.py        # 技能函数
  /ui
    app.py           # Streamlit界面（100行）
  database.db        # SQLite数据库
  .env              # 配置文件
  requirements.txt

# Day 2：核心代码骨架
```

**Day 1实战代码**：

```python
# app/main.py - 核心API（极简版）
from fastapi import FastAPI, HTTPException
from anthropic import Anthropic
import os
from datetime import datetime
import sqlite3

app = FastAPI(title="AI Business Assistant")
client = Anthropic(api_key=os.getenv("CLAUDE_API_KEY"))

# 初始化数据库
def init_db():
    conn = sqlite3.connect('database.db')
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS ai_decisions
                 (id INTEGER PRIMARY KEY, 
                  user_input TEXT,
                  intent TEXT,
                  action TEXT,
                  result TEXT,
                  timestamp TEXT)''')
    conn.commit()
    conn.close()

init_db()

# 核心技能库（硬编码开始，够用就行）
SKILLS = {
    "get_order": lambda order_id: {
        "order_id": order_id,
        "status": "已发货",
        "tracking": "SF1234567890"
    },
    "query_inventory": lambda product_id: {
        "product_id": product_id,
        "stock": 100,
        "warehouse": "深圳仓"
    },
    "send_email": lambda to, content: {
        "sent": True,
        "to": to,
        "timestamp": datetime.now().isoformat()
    }
}

@app.post("/chat")
async def chat(user_input: str):
    """核心对话接口"""
    try:
        # Step 1: 用Claude识别意图并生成执行计划
        response = client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=1000,
            messages=[{
                "role": "user",
                "content": f"""你是企业AI助手。用户说："{user_input}"

可用技能：
- get_order(order_id): 查询订单
- query_inventory(product_id): 查库存  
- send_email(to, content): 发邮件

请分析意图，返回JSON格式执行计划：
{{
  "intent": "意图名称",
  "skill": "技能名称",
  "params": {{"参数": "值"}},
  "response_template": "回复模板"
}}"""
            }]
        )
        
        # Step 2: 解析AI返回的计划
        import json
        plan_text = response.content[0].text
        # 提取JSON（简单处理）
        plan_text = plan_text.replace("```json", "").replace("```", "").strip()
        plan = json.loads(plan_text)
        
        # Step 3: 执行技能
        skill_name = plan["skill"]
        params = plan["params"]
        
        if skill_name in SKILLS:
            result = SKILLS[skill_name](**params)
        else:
            result = {"error": "技能不存在"}
        
        # Step 4: 生成用户响应
        final_response = client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=500,
            messages=[{
                "role": "user",
                "content": f"""执行结果：{json.dumps(result, ensure_ascii=False)}
                
使用这个模板回复用户：{plan['response_template']}"""
            }]
        )
        
        user_message = final_response.content[0].text
        
        # Step 5: 记录决策
        conn = sqlite3.connect('database.db')
        c = conn.cursor()
        c.execute("""INSERT INTO ai_decisions 
                     (user_input, intent, action, result, timestamp) 
                     VALUES (?, ?, ?, ?, ?)""",
                  (user_input, plan["intent"], skill_name, 
                   json.dumps(result), datetime.now().isoformat()))
        conn.commit()
        conn.close()
        
        return {
            "success": True,
            "message": user_message,
            "debug": {
                "intent": plan["intent"],
                "skill": skill_name,
                "result": result
            }
        }
        
    except Exception as e:
        return {"success": False, "error": str(e)}

@app.get("/")
def root():
    return {"status": "AI Assistant Running", "version": "0.1"}

# 运行：uvicorn app.main:app --reload
```

**Day 2实战代码 - Streamlit UI**：

```python
# ui/app.py - 超简单聊天界面
import streamlit as st
import requests
import json

st.set_page_config(page_title="AI业务助手", page_icon="🤖")

st.title("🤖 企业AI业务助手")
st.caption("15天极速版 v0.1")

# 初始化会话
if "messages" not in st.session_state:
    st.session_state.messages = []

# 显示历史消息
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])

# 用户输入
if prompt := st.chat_input("输入您的需求..."):
    # 显示用户消息
    st.session_state.messages.append({"role": "user", "content": prompt})
    with st.chat_message("user"):
        st.markdown(prompt)
    
    # 调用后端API
    with st.chat_message("assistant"):
        with st.spinner("AI正在思考..."):
            try:
                response = requests.post(
                    "http://localhost:8000/chat",
                    params={"user_input": prompt}
                )
                data = response.json()
                
                if data["success"]:
                    st.markdown(data["message"])
                    
                    # 显示调试信息
                    with st.expander("🔍 查看执行详情"):
                        st.json(data["debug"])
                    
                    st.session_state.messages.append({
                        "role": "assistant", 
                        "content": data["message"]
                    })
                else:
                    st.error(f"错误：{data['error']}")
            except Exception as e:
                st.error(f"连接失败：{e}")

# 侧边栏
with st.sidebar:
    st.header("⚙️ 系统状态")
    
    # 检查后端状态
    try:
        health = requests.get("http://localhost:8000/")
        if health.status_code == 200:
            st.success("✅ 后端运行正常")
        else:
            st.error("❌ 后端异常")
    except:
        st.error("❌ 后端未连接")
    
    st.divider()
    
    # 快捷测试
    st.header("🚀 快速测试")
    if st.button("查询订单12345"):
        st.session_state.messages.append({
            "role": "user",
            "content": "查询订单12345的状态"
        })
        st.rerun()
    
    if st.button("查询产品A库存"):
        st.session_state.messages.append({
            "role": "user",
            "content": "产品A还有多少库存？"
        })
        st.rerun()

# 运行：streamlit run ui/app.py
```

### Day 3-5: 3个核心Skill实现

**不要复杂的微服务！直接写函数：**

```python
# app/skills.py - 真实Skill实现（接入真实系统）

import requests
from typing import Dict, Any

class OrderSkill:
    """订单技能"""
    def __init__(self, api_base_url: str):
        self.api_base = api_base_url
    
    def get_order(self, order_id: str) -> Dict[str, Any]:
        """查询订单详情"""
        try:
            # 调用你们内部订单系统API
            response = requests.get(
                f"{self.api_base}/orders/{order_id}",
                headers={"Authorization": f"Bearer {os.getenv('ORDER_API_KEY')}"},
                timeout=5
            )
            response.raise_for_status()
            return response.json()
        except Exception as e:
            return {"error": str(e)}
    
    def update_order_status(self, order_id: str, status: str) -> Dict[str, Any]:
        """更新订单状态"""
        try:
            response = requests.put(
                f"{self.api_base}/orders/{order_id}/status",
                json={"status": status},
                headers={"Authorization": f"Bearer {os.getenv('ORDER_API_KEY')}"},
                timeout=5
            )
            response.raise_for_status()
            return {"success": True, "order_id": order_id, "new_status": status}
        except Exception as e:
            return {"error": str(e)}

class InventorySkill:
    """库存技能"""
    def __init__(self, api_base_url: str):
        self.api_base = api_base_url
    
    def query_inventory(self, product_id: str) -> Dict[str, Any]:
        """查询库存"""
        try:
            response = requests.get(
                f"{self.api_base}/inventory/{product_id}",
                timeout=5
            )
            response.raise_for_status()
            return response.json()
        except Exception as e:
            return {"error": str(e)}

class NotificationSkill:
    """通知技能"""
    def send_email(self, to: str, subject: str, content: str) -> Dict[str, Any]:
        """发送邮件"""
        # 使用SendGrid/阿里云邮件服务
        import sendgrid
        from sendgrid.helpers.mail import Mail
        
        sg = sendgrid.SendGridAPIClient(api_key=os.getenv('SENDGRID_API_KEY'))
        message = Mail(
            from_email='noreply@company.com',
            to_emails=to,
            subject=subject,
            html_content=content
        )
        
        try:
            response = sg.send(message)
            return {"success": True, "status_code": response.status_code}
        except Exception as e:
            return {"error": str(e)}

# 在main.py中注册这些Skill
```

### Day 6-8: Orchestrator增强

```python
# app/orchestrator.py - AI编排器（核心大脑）

from anthropic import Anthropic
import json
from typing import Dict, Any, List

class AIOrchestrator:
    """AI编排器 - 系统大脑"""
    
    def __init__(self, api_key: str):
        self.client = Anthropic(api_key=api_key)
        self.skills = {}  # 注册的技能
        self.conversation_history = []  # 对话历史（简化版）
    
    def register_skill(self, name: str, func: callable, description: str):
        """注册技能"""
        self.skills[name] = {
            "function": func,
            "description": description
        }
    
    def execute(self, user_input: str, user_id: str = "default") -> Dict[str, Any]:
        """执行用户请求"""
        
        # 1. 构建技能清单（给AI看）
        skills_desc = "\n".join([
            f"- {name}: {info['description']}" 
            for name, info in self.skills.items()
        ])
        
        # 2. 让AI生成执行计划
        plan_prompt = f"""你是企业AI助手。用户请求："{user_input}"

可用技能：
{skills_desc}

请分析意图并生成执行计划，严格按此JSON格式返回：
{{
  "intent": "用户意图简述",
  "steps": [
    {{
      "skill": "技能名称",
      "params": {{"参数名": "参数值"}},
      "description": "步骤说明"
    }}
  ],
  "response_template": "用{{{{result}}}}占位符的回复模板"
}}

只返回JSON，不要其他内容。"""
        
        try:
            response = self.client.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=2000,
                messages=[{"role": "user", "content": plan_prompt}]
            )
            
            # 解析计划
            plan_text = response.content[0].text.strip()
            plan_text = plan_text.replace("```json", "").replace("```", "").strip()
            plan = json.loads(plan_text)
            
            # 3. 执行计划中的每个步骤
            results = []
            for step in plan["steps"]:
                skill_name = step["skill"]
                params = step["params"]
                
                if skill_name in self.skills:
                    skill_func = self.skills[skill_name]["function"]
                    result = skill_func(**params)
                    results.append({
                        "skill": skill_name,
                        "params": params,
                        "result": result
                    })
                else:
                    results.append({
                        "skill": skill_name,
                        "error": "技能不存在"
                    })
            
            # 4. 生成最终回复
            final_prompt = f"""执行结果：
{json.dumps(results, ensure_ascii=False, indent=2)}

请用自然、友好的语言回复用户，参考模板：
{plan['response_template']}

直接给出回复内容，不要JSON格式。"""
            
            final_response = self.client.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=1000,
                messages=[{"role": "user", "content": final_prompt}]
            )
            
            user_message = final_response.content[0].text
            
            return {
                "success": True,
                "message": user_message,
                "intent": plan["intent"],
                "steps_executed": len(results),
                "details": results
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "message": "抱歉，处理请求时出错了。"
            }
```

### Day 9-12: 数据记录与基础监控

```python
# app/models.py - 数据模型（SQLAlchemy）

from sqlalchemy import create_engine, Column, Integer, String, Text, Float, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime

Base = declarative_base()

class AIDecision(Base):
    """AI决策记录"""
    __tablename__ = 'ai_decisions'
    
    id = Column(Integer, primary_key=True)
    user_id = Column(String(64))
    user_input = Column(Text)
    intent = Column(String(128))
    skills_used = Column(Text)  # JSON字符串
    result = Column(Text)  # JSON字符串
    success = Column(Integer)  # 1=成功, 0=失败
    execution_time_ms = Column(Float)
    llm_cost = Column(Float)  # 美元
    timestamp = Column(DateTime, default=datetime.now)
    
class SystemMetrics(Base):
    """系统指标"""
    __tablename__ = 'metrics'
    
    id = Column(Integer, primary_key=True)
    metric_name = Column(String(64))
    metric_value = Column(Float)
    timestamp = Column(DateTime, default=datetime.now)

# 创建数据库
engine = create_engine('sqlite:///database.db')
Base.metadata.create_all(engine)
Session = sessionmaker(bind=engine)
```

### Day 13-15: 端到端测试 + 部署

```bash
# Day 13-14: 测试
# 编写测试脚本
python tests/test_e2e.py

# Day 15: 一键部署（使用Railway）
# 1. 注册Railway账号（免费）
# 2. 连接GitHub仓库
# 3. 自动部署

# 或使用Docker（备选）
docker build -t ai-assistant .
docker run -p 8000:8000 ai-assistant
```

**Day 15交付物**：
- ✅ 能接收用户输入
- ✅ AI理解意图
- ✅ 调用至少2个真实技能（订单查询、库存查询）
- ✅ 返回结构化结果
- ✅ 所有决策记录到数据库
- ✅ 部署到可访问的URL

---

## 阶段2: 第16-30天 - 3条核心流程脚本化

**目标**: 把3个最常用的业务流程自动化

### Day 16-17: SOP引擎（极简版）

```python
# app/sop_engine.py - SOP执行引擎

import yaml
from typing import Dict, Any

class SOPEngine:
    """SOP执行引擎"""
    
    def __init__(self, orchestrator: AIOrchestrator):
        self.orchestrator = orchestrator
        self.sops = {}
    
    def load_sop(self, sop_file: str):
        """加载SOP配置"""
        with open(sop_file, 'r', encoding='utf-8') as f:
            sop = yaml.safe_load(f)
            self.sops[sop['id']] = sop
    
    def execute_sop(self, sop_id: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """执行SOP"""
        if sop_id not in self.sops:
            return {"error": "SOP不存在"}
        
        sop = self.sops[sop_id]
        results = []
        
        # 执行SOP中的每个步骤
        for step in sop['steps']:
            step_type = step['type']
            
            if step_type == 'skill_call':
                # 调用技能
                skill_name = step['skill']
                params = self._resolve_params(step['params'], context)
                result = self.orchestrator.skills[skill_name]['function'](**params)
                context[step['output_var']] = result
                results.append(result)
            
            elif step_type == 'decision':
                # 决策逻辑
                condition = self._evaluate_condition(step['condition'], context)
                if condition:
                    # 执行true分支
                    pass
                else:
                    # 执行false分支
                    pass
        
        return {"success": True, "results": results}
    
    def _resolve_params(self, params: Dict, context: Dict) -> Dict:
        """解析参数（支持${变量}）"""
        resolved = {}
        for key, value in params.items():
            if isinstance(value, str) and value.startswith("${"):
                var_name = value[2:-1]
                resolved[key] = context.get(var_name)
            else:
                resolved[key] = value
        return resolved
```

### Day 18-22: 开发3条核心SOP

**SOP 1: 订单延迟处理**

```yaml
# sops/order_delay.yaml
id: order_delay_handler
name: 订单延迟自动处理
description: 自动查询订单、物流，发送道歉邮件和补偿

triggers:
  - intent: "订单延迟查询"
  - keywords: ["延迟", "没到", "物流"]

steps:
  - type: skill_call
    skill: get_order
    params:
      order_id: ${order_id}
    output_var: order
  
  - type: skill_call
    skill: query_logistics
    params:
      tracking_number: ${order.tracking_number}
    output_var: logistics
  
  - type: decision
    condition: logistics.status == 'delayed'
    true_branch:
      - type: skill_call
        skill: generate_apology
        params:
          order_id: ${order_id}
          reason: ${logistics.delay_reason}
        output_var: apology
      
      - type: skill_call
        skill: offer_compensation
        params:
          user_id: ${user_id}
          policy: standard_delay
        output_var: compensation
      
      - type: skill_call
        skill: send_email
        params:
          to: ${order.customer_email}
          subject: 订单延迟通知
          content: ${apology.content}
```

**SOP 2: 库存预警**

```yaml
# sops/inventory_alert.yaml
id: inventory_alert
name: 库存预警自动处理

triggers:
  - event: inventory_low
  - schedule: "0 9 * * *"  # 每天9点检查

steps:
  - type: skill_call
    skill: query_all_inventory
    output_var: inventory_list
  
  - type: decision
    condition: any(item.stock < item.threshold for item in inventory_list)
    true_branch:
      - type: skill_call
        skill: generate_restock_plan
        params:
          low_stock_items: ${low_stock_items}
        output_var: plan
      
      - type: skill_call
        skill: send_email
        params:
          to: "purchasing@company.com"
          subject: 库存预警
          content: ${plan.report}
```

**SOP 3: 智能退款**

```yaml
# sops/smart_refund.yaml
id: smart_refund
name: 智能退款决策

steps:
  - type: skill_call
    skill: get_order
    params:
      order_id: ${order_id}
    output_var: order
  
  - type: skill_call
    skill: get_user_history
    params:
      user_id: ${user_id}
    output_var: history
  
  - type: ai_decision
    prompt: |
      订单金额：${order.amount}
      用户等级：${history.vip_level}
      退款原因：${reason}
      历史退款次数：${history.refund_count}
      
      决策是否批准退款，返回JSON：
      {"approve": true/false, "reason": "原因"}
    output_var: decision
  
  - type: decision
    condition: decision.approve == true
    true_branch:
      - type: skill_call
        skill: process_refund
        params:
          order_id: ${order_id}
          amount: ${order.amount}
```

### Day 23-25: SOP与UI集成

```python
# 在Streamlit UI中添加SOP触发

# ui/app.py 增加
st.sidebar.header("📋 快速SOP")

if st.sidebar.button("🚚 处理订单延迟"):
    order_id = st.sidebar.text_input("订单号")
    if order_id:
        # 调用SOP API
        response = requests.post(
            "http://localhost:8000/sop/execute",
            json={"sop_id": "order_delay_handler", "context": {"order_id": order_id}}
        )
        st.write(response.json())
```

### Day 26-30: 监控看板V1.0

```python
# ui/dashboard.py - 监控看板

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import requests

st.set_page_config(page_title="AI助手监控看板", layout="wide")

st.title("📊 AI助手监控看板 V1.0")

# 刷新按钮
col1, col2, col3 = st.columns([1, 1, 4])
with col1:
    if st.button("🔄 刷新数据"):
        st.rerun()
with col2:
    auto_refresh = st.checkbox("自动刷新（30秒）")

if auto_refresh:
    import time
    time.sleep(30)
    st.rerun()

# 获取实时数据
try:
    metrics = requests.get("http://localhost:8000/metrics").json()
except:
    st.error("❌ 无法连接后端")
    st.stop()

# === 核心指标 ===
st.header("📈 核心指标")
metric_cols = st.columns(4)

with metric_cols[0]:
    st.metric(
        label="今日处理量",
        value=metrics.get("today_total", 0),
        delta=f"+{metrics.get('today_delta', 0)} vs昨天"
    )

with metric_cols[1]:
    success_rate = metrics.get("success_rate", 0)
    st.metric(
        label="成功率",
        value=f"{success_rate:.1%}",
        delta=f"{metrics.get('success_rate_delta', 0):.1%}"
    )

with metric_cols[2]:
    st.metric(
        label="平均响应时间",
        value=f"{metrics.get('avg_response_ms', 0):.0f}ms",
        delta=f"{metrics.get('response_delta', 0):.0f}ms"
    )

with metric_cols[3]:
    st.metric(
        label="今日成本",
        value=f"${metrics.get('today_cost', 0):.2f}",
        delta=f"${metrics.get('cost_delta', 0):.2f}"
    )

st.divider()

# === 实时告警 ===
st.header("🚨 实时告警")
alerts = metrics.get("alerts", [])

if alerts:
    for alert in alerts:
        if alert["level"] == "critical":
            st.error(f"🔴 {alert['message']}")
        elif alert["level"] == "warning":
            st.warning(f"🟡 {alert['message']}")
else:
    st.success("✅ 系统运行正常，无告警")

st.divider()

# === 趋势图表 ===
col_left, col_right = st.columns(2)

with col_left:
    st.subheader("📊 24小时处理量趋势")
    # 获取历史数据
    history = pd.DataFrame(metrics.get("hourly_stats", []))
    if not history.empty:
        fig = px.line(
            history, 
            x='hour', 
            y='count',
            title='每小时处理量'
        )
        st.plotly_chart(fig, use_container_width=True)

with col_right:
    st.subheader("🎯 意图分布")
    intent_data = pd.DataFrame(metrics.get("intent_distribution", []))
    if not intent_data.empty:
        fig = px.pie(
            intent_data,
            values='count',
            names='intent',
            title='意图类型分布'
        )
        st.plotly_chart(fig, use_container_width=True)

st.divider()

# === SOP执行统计 ===
st.header("📋 SOP执行统计")
sop_stats = pd.DataFrame(metrics.get("sop_stats", []))

if not sop_stats.empty:
    st.dataframe(
        sop_stats,
        column_config={
            "sop_name": "SOP名称",
            "total": "执行次数",
            "success": "成功次数",
            "success_rate": st.column_config.ProgressColumn(
                "成功率",
                format="%.1f%%",
                min_value=0,
                max_value=100,
            ),
            "avg_time": "平均耗时(ms)"
        },
        hide_index=True,
        use_container_width=True
    )

st.divider()

# === 最近决策日志 ===
st.header("📝 最近决策日志")
logs = pd.DataFrame(metrics.get("recent_logs", []))

if not logs.empty:
    st.dataframe(
        logs,
        column_config={
            "timestamp": "时间",
            "user_input": "用户输入",
            "intent": "意图",
            "result": "结果",
            "execution_time": "耗时(ms)"
        },
        hide_index=True,
        use_container_width=True
    )

# 运行：streamlit run ui/dashboard.py --server.port 8501
```

**Day 30交付物**：
- ✅ 3条SOP脚本化并测试通过
- ✅ 监控看板上线，支持实时刷新
- ✅ 异常告警功能（成功率<90%、响应时间>2s）
- ✅ 核心指标可视化

---

## 阶段3: 第31-45天 - MVP完善与测试账号接入

### Day 31-35: 用户系统与权限

```python
# app/auth.py - 极简认证

from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt
from datetime import datetime, timedelta

SECRET_KEY = "your-secret-key"  # 生产环境用环境变量
ALGORITHM = "HS256"

security = HTTPBearer()

# 测试账号（硬编码，够用）
TEST_USERS = {
    "test001": {"password": "test123", "role": "viewer", "name": "测试账号1"},
    "test002": {"password": "test456", "role": "admin", "name": "测试账号2"},
}

def create_token(user_id: str) -> str:
    """生成JWT token"""
    expire = datetime.utcnow() + timedelta(days=7)
    payload = {"sub": user_id, "exp": expire}
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """验证token"""
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        user_id = payload.get("sub")
        if user_id not in TEST_USERS:
            raise HTTPException(status_code=401, detail="用户不存在")
        return user_id
    except:
        raise HTTPException(status_code=401, detail="Token无效")

# 在main.py中添加登录接口
@app.post("/login")
def login(user_id: str, password: str):
    if user_id in TEST_USERS and TEST_USERS[user_id]["password"] == password:
        token = create_token(user_id)
        return {"token": token, "user": TEST_USERS[user_id]}
    raise HTTPException(status_code=401, detail="用户名或密码错误")

# 保护核心接口
@app.post("/chat")
async def chat(user_input: str, user_id: str = Depends(verify_token)):
    # ... 原有逻辑
```

### Day 36-40: 多轮对话与上下文

```python
# app/session.py - 会话管理（Redis太重，用内存+定期落盘）

from typing import Dict, List
import json
from datetime import datetime, timedelta

class SessionManager:
    """会话管理器"""
    
    def __init__(self):
        self.sessions: Dict[str, Session] = {}
    
    def get_or_create(self, user_id: str) -> 'Session':
        """获取或创建会话"""
        if user_id not in self.sessions:
            self.sessions[user_id] = Session(user_id)
        return self.sessions[user_id]
    
    def cleanup_expired(self):
        """清理过期会话"""
        now = datetime.now()
        expired = [
            uid for uid, session in self.sessions.items()
            if now - session.last_active > timedelta(minutes=30)
        ]
        for uid in expired:
            del self.sessions[uid]

class Session:
    """会话对象"""
    
    def __init__(self, user_id: str):
        self.user_id = user_id
        self.history: List[Dict] = []
        self.context: Dict = {}
        self.last_active = datetime.now()
    
    def add_message(self, role: str, content: str):
        """添加消息"""
        self.history.append({
            "role": role,
            "content": content,
            "timestamp": datetime.now().isoformat()
        })
        self.last_active = datetime.now()
        
        # 只保留最近10轮
        if len(self.history) > 20:
            self.history = self.history[-20:]
    
    def get_context_summary(self) -> str:
        """获取上下文摘要"""
        if len(self.history) < 2:
            return ""
        
        recent = self.history[-6:]  # 最近3轮对话
        summary = "\n".join([
            f"{msg['role']}: {msg['content']}" 
            for msg in recent
        ])
        return f"最近对话：\n{summary}"

# 在orchestrator中使用
def execute(self, user_input: str, session: Session) -> Dict:
    # 添加上下文
    context_summary = session.get_context_summary()
    enhanced_prompt = f"{context_summary}\n\n当前用户输入：{user_input}"
    
    # ... 其余逻辑
    
    # 记录对话
    session.add_message("user", user_input)
    session.add_message("assistant", result_message)
```

### Day 41-43: 错误处理与重试

```python
# app/retry.py - 重试机制

from functools import wraps
import time
import logging

def retry(max_attempts=3, delay=1, backoff=2):
    """重试装饰器"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            attempts = 0
            current_delay = delay
            
            while attempts < max_attempts:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    attempts += 1
                    if attempts >= max_attempts:
                        logging.error(f"Failed after {max_attempts} attempts: {e}")
                        raise
                    
                    logging.warning(f"Attempt {attempts} failed, retrying in {current_delay}s...")
                    time.sleep(current_delay)
                    current_delay *= backoff
        
        return wrapper
    return decorator

# 使用示例
@retry(max_attempts=3, delay=1)
def call_external_api(url: str):
    response = requests.get(url, timeout=5)
    response.raise_for_status()
    return response.json()
```

### Day 44-45: 测试与文档

```python
# tests/test_e2e.py - 端到端测试

import pytest
import requests

BASE_URL = "http://localhost:8000"

def test_login():
    """测试登录"""
    response = requests.post(
        f"{BASE_URL}/login",
        json={"user_id": "test001", "password": "test123"}
    )
    assert response.status_code == 200
    assert "token" in response.json()

def test_chat_order_query():
    """测试订单查询对话"""
    # 先登录
    login_resp = requests.post(
        f"{BASE_URL}/login",
        json={"user_id": "test001", "password": "test123"}
    )
    token = login_resp.json()["token"]
    
    # 发起对话
    response = requests.post(
        f"{BASE_URL}/chat",
        params={"user_input": "查询订单12345的状态"},
        headers={"Authorization": f"Bearer {token}"}
    )
    
    assert response.status_code == 200
    data = response.json()
    assert data["success"] == True
    assert "订单" in data["message"]

def test_sop_execution():
    """测试SOP执行"""
    login_resp = requests.post(
        f"{BASE_URL}/login",
        json={"user_id": "test002", "password": "test456"}
    )
    token = login_resp.json()["token"]
    
    response = requests.post(
        f"{BASE_URL}/sop/execute",
        json={
            "sop_id": "order_delay_handler",
            "context": {"order_id": "12345", "user_id": "test001"}
        },
        headers={"Authorization": f"Bearer {token}"}
    )
    
    assert response.status_code == 200

# 运行：pytest tests/test_e2e.py -v
```

**Day 45交付物**：
- ✅ 测试账号系统（至少2个测试账号）
- ✅ 多轮对话支持
- ✅ 错误处理和重试机制
- ✅ 完整的E2E测试
- ✅ 部署到测试环境
- ✅ 用户手册（1页纸）

---

## 技术栈总结（极简版）

| 组件 | 技术选择 | 理由 |
|-----|---------|------|
| 后端框架 | FastAPI | 最快的Python Web框架 |
| 前端UI | Streamlit | 零前端经验也能做界面 |
| 数据库 | SQLite → PostgreSQL | 开发用SQLite，生产换PostgreSQL |
| LLM | Claude API | 直接调用，无需部署 |
| 部署 | Railway/Render | 免费托管，自动部署 |
| 监控 | 自建（Streamlit） | 省钱，够用 |
| 认证 | JWT | 轻量级，标准方案 |

---

## 时间线与检查点

```
Day 1-2   │ 环境搭建 + 骨架代码
Day 3-5   │ 核心Skill实现
Day 6-8   │ Orchestrator增强
Day 9-12  │ 数据记录 + 基础监控
Day 13-15 │ 端到端测试 + 部署
          │ ✅ 检查点1：展示给老板
──────────┼─────────────────────────────
Day 16-17 │ SOP引擎实现
Day 18-22 │ 3条SOP开发
Day 23-25 │ SOP与UI集成
Day 26-30 │ 监控看板V1.0
          │ ✅ 检查点2：3条流程演示
──────────┼─────────────────────────────
Day 31-35 │ 用户系统 + 权限
Day 36-40 │ 多轮对话 + 上下文
Day 41-43 │ 错误处理 + 重试
Day 44-45 │ 测试 + 文档
          │ ✅ 检查点3：MVP验收
```

---

## 关键成功因素

### 必须做对的3件事：

1. **Day 1-2绝对不能拖**
   - 环境一次搞定
   - 用最熟悉的技术栈
   - 别想着换技术

2. **专注核心价值**
   - 只做3个Skill（订单、库存、通知）
   - 只做3条SOP
   - 其他功能全部砍掉

3. **每周五给老板看进展**
   - Week 2: 演示端到端流程
   - Week 4: 演示3条SOP
   - Week 6: 演示完整MVP

### 可以暂时不做的：

- ❌ 微服务架构
- ❌ 复杂的权限系统
- ❌ 完美的UI设计
- ❌ 详细的日志分析
- ❌ 高可用部署
- ❌ 性能优化
- ❌ 单元测试全覆盖

这些等MVP跑通后，有时间再补！

---

## 应急预案

### 如果进度落后怎么办？

| 问题 | 解决方案 |
|-----|---------|
| Day 5还没跑通端到端 | 用Mock数据，先把流程走通 |
| LLM响应太慢 | 加缓存，相似问题直接返回 |
| Skill对接困难 | 先Mock，标记TODO，后续补 |
| 看板做不出来 | 用Excel手动更新也行 |
| 测试账号来不及 | 去掉认证，直接开放使用 |

### 救命工具清单：

- **ChatGPT/Claude**: 卡住了就问AI
- **GitHub Copilot**: 代码自动补全
- **Cursor**: AI辅助编程
- **Streamlit Docs**: 界面问题看文档
- **FastAPI Docs**: API问题看官方例子

---

## 最后的建议

### 给你的3个锦囊：

**锦囊1 - 时间管理**：
- 上午写代码（思路最清晰）
- 下午调试和测试
- 晚上写文档和准备演示
- 周末休息（不然撑不住45天）

**锦囊2 - 和老板沟通**：
- 每周五下午4点，固定汇报
- 准备3分钟演示视频
- 提前说明风险和依赖
- 要资源时直接说（比如需要API key）

**锦囊3 - 保持信心**：
- Day 15可能很粗糙，**但能跑通就是胜利**
- Day 30功能不完美，**但有3个案例就够**
- Day 45不是最终版，**但证明了可行性**

---

**记住：完成比完美更重要！先做出来，再优化。**

**你能行的！💪**
