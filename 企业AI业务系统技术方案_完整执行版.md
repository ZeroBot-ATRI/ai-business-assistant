# ä¼ä¸šAIä¸šåŠ¡ç³»ç»ŸæŠ€æœ¯æ–¹æ¡ˆ - å®Œæ•´æ‰§è¡Œç‰ˆ

## 1. é¡¹ç›®æ¦‚è¿°ä¸å®šä½

### 1.1 é¡¹ç›®èƒŒæ™¯
æœ¬é¡¹ç›®æ—¨åœ¨æ„å»ºä¸€ä¸ª**çœŸæ­£å…·å¤‡ä»£ç†èƒ½åŠ›çš„AIä¸šåŠ¡åŠ©æ‰‹**,ä¸ä»…èƒ½ç†è§£å’Œå›ç­”é—®é¢˜,æ›´èƒ½è‡ªä¸»æ‰§è¡Œç«¯åˆ°ç«¯çš„å¤æ‚ä¸šåŠ¡æµç¨‹ã€‚ç³»ç»Ÿèåˆ"ä»£ç†å¼å•†åŠ¡æ¶æ„"(Agential Commerce Architecture),é€šè¿‡è‡ªç„¶è¯­è¨€äº¤äº’å®Œæˆä»æ„å›¾è¯†åˆ«åˆ°ä¸šåŠ¡æ‰§è¡Œçš„å…¨é“¾è·¯é—­ç¯ã€‚

### 1.2 æ ¸å¿ƒä»·å€¼ä¸»å¼ 
- **æ™ºèƒ½ç†è§£**: å¤šè½®å¯¹è¯ä¸Šä¸‹æ–‡ç®¡ç†,ç²¾å‡†ç†è§£ä¸šåŠ¡æ„å›¾
- **è‡ªä¸»æ‰§è¡Œ**: è‡ªåŠ¨åŒ–å®Œæˆ80%ä»¥ä¸Šçš„é‡å¤æ€§ä¸šåŠ¡æ“ä½œ
- **å¯ä¿¡å†³ç­–**: æ¯ä¸ªå†³ç­–å¯å®¡è®¡ã€å¯è§£é‡Šã€å¯å›æ»š
- **æŒç»­å­¦ä¹ **: ä»ä¸šåŠ¡åé¦ˆä¸­ä¼˜åŒ–å†³ç­–è´¨é‡

### 1.3 ç³»ç»Ÿèƒ½åŠ›çŸ©é˜µ

| èƒ½åŠ›ç»´åº¦ | ä¼ ç»Ÿç³»ç»Ÿ | ç®€å•èŠå¤©æœºå™¨äºº | æœ¬AIåŠ©æ‰‹ |
|---------|---------|---------------|---------|
| è‡ªç„¶è¯­è¨€äº¤äº’ | âŒ | âœ… | âœ… |
| å¤šè½®å¯¹è¯ä¸Šä¸‹æ–‡ | âŒ | éƒ¨åˆ† | âœ… |
| è‡ªä¸»æ‰§è¡Œä¸šåŠ¡ | âŒ | âŒ | âœ… |
| è·¨ç³»ç»Ÿç¼–æ’ | æ‰‹åŠ¨ | âŒ | âœ… |
| å¼‚å¸¸å¤„ç†ä¸è¡¥å¿ | æ‰‹åŠ¨ | âŒ | âœ… |
| å†³ç­–å¯å®¡è®¡æ€§ | æœ‰é™ | âŒ | âœ… |
| æƒé™æ§åˆ¶ | âœ… | æœ‰é™ | âœ… |

---

## 2. æ ¸å¿ƒæ¶æ„è®¾è®¡(å¢å¼ºç‰ˆ)

### 2.1 æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ç”¨æˆ·äº¤äº’å±‚                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚Web Portalâ”‚  â”‚Mobile Appâ”‚  â”‚Slack Bot â”‚  â”‚  API     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚             â”‚             â”‚             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  AIå¯¹è¯ç®¡ç†å±‚                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Session Manager (ä¼šè¯ç®¡ç†)                          â”‚  â”‚
â”‚  â”‚  - å¤šè½®å¯¹è¯ä¸Šä¸‹æ–‡  - çŠ¶æ€æœºç®¡ç†  - ä¼šè¯æ¢å¤         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Intent Recognizer (æ„å›¾è¯†åˆ«)                        â”‚  â”‚
â”‚  â”‚  - NLUå¼•æ“  - å®ä½“æå–  - æ§½ä½å¡«å……  - æ„å›¾æ¶ˆæ­§      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              AIæ ¸å¿ƒåè°ƒå±‚ (Orchestrator)                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  SOP Router (SOPè·¯ç”±)                                â”‚  â”‚
â”‚  â”‚  - SOPåŒ¹é…  - å‰ç½®æ¡ä»¶éªŒè¯  - æƒé™æ£€æŸ¥              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Model Router (æ¨¡å‹è·¯ç”±)                             â”‚  â”‚
â”‚  â”‚  - æˆæœ¬ä¼˜åŒ–  - æ•æ„Ÿåº¦è·¯ç”±  - èƒ½åŠ›åŒ¹é…               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Execution Engine (æ‰§è¡Œå¼•æ“)                         â”‚  â”‚
â”‚  â”‚  - å·¥ä½œæµç¼–æ’  - äº‹åŠ¡ç®¡ç†  - è¡¥å¿æœºåˆ¶  - é‡è¯•ç­–ç•¥   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æŠ€èƒ½æ‰§è¡Œå±‚ (Skills)                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚å®¢æˆ·ç®¡ç†  â”‚ â”‚è®¢å•å¤„ç†  â”‚ â”‚åº“å­˜ç‰©æµ  â”‚ â”‚æ”¯ä»˜ç»“ç®—  â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚è¥é”€è‡ªåŠ¨åŒ–â”‚ â”‚å®¢æˆ·æœåŠ¡  â”‚ â”‚æ•°æ®åˆ†æ  â”‚ â”‚é€šçŸ¥æœåŠ¡  â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚            â”‚            â”‚            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   èµ„æºå±‚ (Resources)                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚  æ•°æ®åº“  â”‚ â”‚ å¤–éƒ¨API  â”‚ â”‚æ¶ˆæ¯é˜Ÿåˆ—  â”‚ â”‚ æ–‡ä»¶å­˜å‚¨ â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   æ¨ªå‘æ”¯æ’‘å±‚                                 â”‚
â”‚  è®¤è¯æˆæƒ | å®¡è®¡æ—¥å¿— | ç›‘æ§å‘Šè­¦ | é…ç½®ä¸­å¿ƒ | å¯†é’¥ç®¡ç†       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 AIå¯¹è¯ç®¡ç†å±‚(æ–°å¢)

#### 2.2.1 ä¼šè¯ç®¡ç†å™¨ (Session Manager)

**æ ¸å¿ƒèŒè´£:**
1. ç»´æŠ¤å¤šè½®å¯¹è¯ä¸Šä¸‹æ–‡
2. ç®¡ç†ç”¨æˆ·çŠ¶æ€æœº
3. æ”¯æŒä¼šè¯æš‚åœä¸æ¢å¤
4. å¤„ç†å¹¶å‘ä¼šè¯

**æŠ€æœ¯å®ç°:**

```python
# ä¼šè¯çŠ¶æ€æ•°æ®ç»“æ„
class SessionState:
    session_id: str
    user_id: str
    context: Dict[str, Any]  # å¯¹è¯ä¸Šä¸‹æ–‡
    history: List[Message]   # å¯¹è¯å†å²
    current_sop: Optional[str]  # å½“å‰æ‰§è¡Œçš„SOP
    pending_slots: Dict[str, Any]  # å¾…å¡«å……çš„æ§½ä½
    state: SessionStateEnum  # IDLE | COLLECTING_INFO | EXECUTING | WAITING_CONFIRMATION
    created_at: datetime
    last_active: datetime
    ttl: int  # ä¼šè¯è¿‡æœŸæ—¶é—´(ç§’)

# çŠ¶æ€æœºå®šä¹‰
class SessionStateMachine:
    """
    çŠ¶æ€è½¬æ¢:
    IDLE â†’ COLLECTING_INFO â†’ EXECUTING â†’ WAITING_CONFIRMATION â†’ IDLE
           â†“                    â†“
         ERROR              COMPENSATING
    """
    
    def transition(self, event: str) -> SessionState:
        # å®ç°çŠ¶æ€è½¬æ¢é€»è¾‘
        pass
```

**å­˜å‚¨æ–¹æ¡ˆ:**
- **çŸ­æœŸä¼šè¯**: Redis (TTL: 30åˆ†é’Ÿ)
- **é•¿æœŸä¼šè¯**: PostgreSQL (éœ€è¦æŒä¹…åŒ–çš„ä¼šè¯)
- **ä¼šè¯å¿«ç…§**: æ¯æ¬¡çŠ¶æ€å˜æ›´ååŒæ­¥åˆ°æŒä¹…å±‚

#### 2.2.2 æ„å›¾è¯†åˆ«å™¨ (Intent Recognizer)

**æ ¸å¿ƒåŠŸèƒ½:**

```python
class IntentRecognizer:
    def recognize(self, user_input: str, context: SessionContext) -> Intent:
        """
        æ„å›¾è¯†åˆ«æµç¨‹:
        1. é¢„å¤„ç†è¾“å…¥
        2. å®ä½“æå–(NER)
        3. æ„å›¾åˆ†ç±»
        4. æ§½ä½å¡«å……
        5. æ„å›¾æ¶ˆæ­§
        """
        # 1. é¢„å¤„ç†
        normalized_input = self.preprocess(user_input)
        
        # 2. å®ä½“æå–
        entities = self.extract_entities(normalized_input)
        
        # 3. æ„å›¾åˆ†ç±»(æ··åˆç­–ç•¥)
        intent_candidates = []
        
        # 3a. åŸºäºè§„åˆ™çš„æ„å›¾åŒ¹é…(å¿«é€Ÿè·¯å¾„)
        rule_based_intent = self.match_by_rules(normalized_input)
        if rule_based_intent and rule_based_intent.confidence > 0.9:
            return rule_based_intent
        
        # 3b. åŸºäºLLMçš„æ„å›¾è¯†åˆ«
        llm_intent = self.classify_by_llm(normalized_input, context)
        intent_candidates.append(llm_intent)
        
        # 3c. åŸºäºå‘é‡ç›¸ä¼¼åº¦çš„æ„å›¾æ£€ç´¢
        vector_intent = self.retrieve_by_vector(normalized_input)
        intent_candidates.append(vector_intent)
        
        # 4. æ„å›¾èåˆä¸æ¶ˆæ­§
        final_intent = self.disambiguate(intent_candidates, context)
        
        # 5. æ§½ä½å¡«å……
        final_intent.slots = self.fill_slots(final_intent, entities, context)
        
        return final_intent

class Intent:
    name: str  # ä¾‹: "QueryOrderStatus"
    confidence: float
    slots: Dict[str, Slot]
    required_slots: List[str]
    sop_mappings: List[str]  # å¯æ‰§è¡Œçš„SOPåˆ—è¡¨
    
class Slot:
    name: str
    value: Any
    confidence: float
    is_filled: bool
    validation_rule: Optional[str]
```

**æ„å›¾åˆ†ç±»ç­–ç•¥(ä¸‰å±‚æ¨¡å‹):**

| å±‚çº§ | æ–¹æ³• | é€‚ç”¨åœºæ™¯ | å»¶è¿Ÿ |
|-----|------|---------|------|
| L1 | è§„åˆ™åŒ¹é… | é«˜é¢‘ã€æ˜ç¡®æ„å›¾ | <10ms |
| L2 | å‘é‡æ£€ç´¢ | æ¨¡ç³Šè¡¨è¾¾ã€è¯­ä¹‰ç›¸ä¼¼ | <50ms |
| L3 | LLMæ¨ç† | å¤æ‚ã€æ­§ä¹‰æ„å›¾ | 200-500ms |

**æ§½ä½å¡«å……æœºåˆ¶:**

```python
class SlotFiller:
    def fill_iteratively(self, intent: Intent, session: SessionState) -> Intent:
        """è¿­ä»£å¼æ§½ä½å¡«å……"""
        missing_slots = self.get_missing_slots(intent)
        
        if not missing_slots:
            return intent  # æ‰€æœ‰æ§½ä½å·²å¡«å……
        
        # ä»å†å²å¯¹è¯ä¸­å°è¯•å¡«å……
        for slot_name in missing_slots:
            value = self.extract_from_history(slot_name, session.history)
            if value:
                intent.slots[slot_name] = value
        
        # ä»æœ‰ç¼ºå¤±,ä¸»åŠ¨è¯¢é—®
        missing_slots = self.get_missing_slots(intent)
        if missing_slots:
            session.state = SessionStateEnum.COLLECTING_INFO
            session.pending_slots = missing_slots
            # ç”Ÿæˆè¿½é—®
            question = self.generate_clarification_question(missing_slots[0])
            return None  # éœ€è¦ç”¨æˆ·è¡¥å……ä¿¡æ¯
        
        return intent
```

### 2.3 AIæ ¸å¿ƒåè°ƒå™¨ (Orchestrator - å¢å¼ºç‰ˆ)

#### 2.3.1 æ¶æ„é€‰æ‹©: **æ–¹æ¡ˆA+ (å¢å¼ºä¸­å¤®åŒ–)**

åœ¨åŸæ–¹æ¡ˆAåŸºç¡€ä¸Š,å¢åŠ ä»¥ä¸‹å¢å¼º:

**å¢å¼ºç‚¹1: åˆ†å¸ƒå¼äº‹åŠ¡æ”¯æŒ**

```python
class EnhancedOrchestrator:
    def __init__(self):
        self.saga_coordinator = SagaCoordinator()
        self.model_router = ModelRouter()
        self.execution_engine = ExecutionEngine()
        self.audit_logger = AuditLogger()
    
    async def execute_sop(self, sop: SOP, context: ExecutionContext) -> Result:
        """
        æ‰§è¡ŒSOPçš„å®Œæ•´æµç¨‹:
        1. å‰ç½®æ£€æŸ¥
        2. äº‹åŠ¡ç¼–æ’
        3. æ‰§è¡Œç›‘æ§
        4. å¼‚å¸¸å¤„ç†
        5. å®¡è®¡è®°å½•
        """
        execution_id = generate_execution_id()
        
        try:
            # 1. å‰ç½®æ£€æŸ¥
            self.validate_preconditions(sop, context)
            self.check_permissions(context.user_id, sop.required_permissions)
            
            # 2. åˆå§‹åŒ–SAGAäº‹åŠ¡
            saga_context = self.saga_coordinator.begin_saga(
                saga_id=execution_id,
                steps=sop.steps,
                compensation_strategy=sop.compensation_strategy
            )
            
            # 3. æ‰§è¡ŒSOPæ­¥éª¤
            for step in sop.steps:
                # 3a. æ¨¡å‹è·¯ç”±å†³ç­–
                if step.type == "model_call":
                    model = self.model_router.route(
                        task=step.task_type,
                        context=context,
                        policy=step.router_policy
                    )
                    step.model = model
                
                # 3b. æ‰§è¡Œæ­¥éª¤
                step_result = await self.execution_engine.execute_step(
                    step=step,
                    context=context,
                    saga_context=saga_context
                )
                
                # 3c. è®°å½•æ‰§è¡Œè½¨è¿¹
                self.audit_logger.log_step(
                    execution_id=execution_id,
                    step=step,
                    result=step_result
                )
                
                # 3d. æ£€æŸ¥æ˜¯å¦éœ€è¦è¡¥å¿
                if step_result.status == "FAILED":
                    await self.saga_coordinator.compensate(saga_context)
                    raise ExecutionException(f"Step {step.id} failed")
            
            # 4. æäº¤SAGA
            await self.saga_coordinator.commit_saga(saga_context)
            
            # 5. è®°å½•æˆåŠŸå†³ç­–
            self.audit_logger.log_decision(
                execution_id=execution_id,
                sop=sop,
                context=context,
                result="SUCCESS"
            )
            
            return Result(status="SUCCESS", data=saga_context.output)
        
        except Exception as e:
            # è§¦å‘è¡¥å¿
            await self.saga_coordinator.compensate(saga_context)
            
            # è®°å½•å¤±è´¥å†³ç­–
            self.audit_logger.log_decision(
                execution_id=execution_id,
                sop=sop,
                context=context,
                result="FAILED",
                error=str(e)
            )
            
            return Result(status="FAILED", error=str(e))
```

**å¢å¼ºç‚¹2: æ™ºèƒ½æ¨¡å‹è·¯ç”±å™¨**

```python
class ModelRouter:
    def route(self, task: str, context: ExecutionContext, policy: str) -> ModelConfig:
        """
        ä¸‰ç»´è·¯ç”±ç­–ç•¥:
        1. æ•æ„Ÿåº¦ç»´åº¦: æ•°æ®æ•æ„Ÿæ€§å†³å®šæ˜¯å¦ä½¿ç”¨æœ¬åœ°æ¨¡å‹
        2. å¤æ‚åº¦ç»´åº¦: ä»»åŠ¡å¤æ‚åº¦å†³å®šæ¨¡å‹èƒ½åŠ›
        3. æˆæœ¬ç»´åº¦: é¢„ç®—çº¦æŸå†³å®šæ¨¡å‹é€‰æ‹©
        """
        score_matrix = {}
        
        for model in self.available_models:
            # è®¡ç®—æ•æ„Ÿåº¦å¾—åˆ†
            sensitivity_score = self.calc_sensitivity_score(
                model, context.sensitivity_level
            )
            
            # è®¡ç®—èƒ½åŠ›å¾—åˆ†
            capability_score = self.calc_capability_score(
                model, task
            )
            
            # è®¡ç®—æˆæœ¬å¾—åˆ†
            cost_score = self.calc_cost_score(
                model, context.budget_constraint
            )
            
            # åŠ æƒç»¼åˆå¾—åˆ†
            total_score = (
                sensitivity_score * 0.4 +
                capability_score * 0.4 +
                cost_score * 0.2
            )
            
            score_matrix[model] = total_score
        
        # é€‰æ‹©å¾—åˆ†æœ€é«˜çš„æ¨¡å‹
        selected_model = max(score_matrix, key=score_matrix.get)
        
        # è®°å½•è·¯ç”±å†³ç­–
        self.log_routing_decision(
            task=task,
            selected_model=selected_model,
            score_matrix=score_matrix,
            policy=policy
        )
        
        return selected_model

# è·¯ç”±ç­–ç•¥é…ç½®ç¤ºä¾‹
ROUTING_POLICIES = {
    "financial_sensitive": {
        "allowed_models": ["vertex-ai-private", "self-hosted-llama"],
        "sensitivity_threshold": 0.8,
        "max_cost_per_call": 0.01
    },
    "complex_generation": {
        "preferred_models": ["claude-opus-4", "gpt-4"],
        "min_capability_score": 0.9,
        "max_latency_ms": 3000
    },
    "simple_classification": {
        "preferred_models": ["claude-haiku", "gpt-3.5-turbo"],
        "max_cost_per_call": 0.001,
        "cache_enabled": True
    }
}
```

#### 2.3.2 SOPæ‰§è¡Œå¼•æ“

```python
class ExecutionEngine:
    async def execute_step(
        self, 
        step: SOPStep, 
        context: ExecutionContext,
        saga_context: SagaContext
    ) -> StepResult:
        """æ‰§è¡Œå•ä¸ªSOPæ­¥éª¤"""
        
        if step.type == "skill_call":
            return await self.execute_skill(step, context)
        
        elif step.type == "model_call":
            return await self.execute_model(step, context)
        
        elif step.type == "decision_logic":
            return await self.execute_decision(step, context)
        
        elif step.type == "parallel_execution":
            return await self.execute_parallel(step, context)
        
        elif step.type == "human_approval":
            return await self.request_human_approval(step, context)
        
        else:
            raise ValueError(f"Unknown step type: {step.type}")
    
    async def execute_skill(self, step: SOPStep, context: ExecutionContext) -> StepResult:
        """æ‰§è¡ŒæŠ€èƒ½è°ƒç”¨"""
        skill = self.skill_registry.get(step.skill_name)
        
        # å‡†å¤‡è¾“å…¥å‚æ•°
        input_params = self.prepare_params(step.input, context)
        
        # å¹‚ç­‰æ€§æ£€æŸ¥
        if step.idempotent and (cached := self.check_idempotent_cache(step, input_params)):
            return cached
        
        # æ‰§è¡ŒæŠ€èƒ½
        try:
            result = await skill.execute(
                params=input_params,
                timeout=step.timeout,
                retry_policy=step.retry_policy
            )
            
            # ç¼“å­˜ç»“æœ
            if step.idempotent:
                self.cache_result(step, input_params, result)
            
            return StepResult(status="SUCCESS", data=result)
        
        except Exception as e:
            # æ‰§è¡Œé‡è¯•é€»è¾‘
            if step.retry_policy:
                return await self.retry_execution(step, context, e)
            raise e
```

### 2.4 æŠ€èƒ½åº“ (Skills - è¯¦ç»†å®ç°)

#### 2.4.1 æŠ€èƒ½æ¥å£æ ‡å‡†

```python
from abc import ABC, abstractmethod
from typing import Any, Dict, Optional
from pydantic import BaseModel

class SkillMetadata(BaseModel):
    """æŠ€èƒ½å…ƒæ•°æ®"""
    skill_id: str
    name: str
    description: str
    version: str
    category: str  # customer, order, inventory, payment, etc.
    input_schema: Dict[str, Any]
    output_schema: Dict[str, Any]
    required_permissions: List[str]
    dependencies: List[str]  # ä¾èµ–çš„å…¶ä»–æŠ€èƒ½
    sla: SkillSLA
    
class SkillSLA(BaseModel):
    """æœåŠ¡çº§åˆ«åè®®"""
    max_latency_ms: int
    success_rate_threshold: float
    concurrent_limit: int

class BaseSkill(ABC):
    """æŠ€èƒ½åŸºç±»"""
    
    def __init__(self, metadata: SkillMetadata):
        self.metadata = metadata
        self.logger = get_logger(f"skill.{metadata.name}")
    
    @abstractmethod
    async def execute(
        self, 
        params: Dict[str, Any],
        context: ExecutionContext
    ) -> Dict[str, Any]:
        """æ‰§è¡ŒæŠ€èƒ½é€»è¾‘"""
        pass
    
    async def validate_input(self, params: Dict[str, Any]) -> bool:
        """éªŒè¯è¾“å…¥å‚æ•°"""
        schema = self.metadata.input_schema
        # ä½¿ç”¨jsonschemaæˆ–pydanticéªŒè¯
        return validate_against_schema(params, schema)
    
    async def check_preconditions(self, context: ExecutionContext) -> bool:
        """æ£€æŸ¥å‰ç½®æ¡ä»¶"""
        # æ£€æŸ¥æƒé™
        if not self.has_required_permissions(context):
            raise PermissionDeniedError(
                f"User {context.user_id} lacks permissions: "
                f"{self.metadata.required_permissions}"
            )
        
        # æ£€æŸ¥ä¾èµ–
        for dep_skill in self.metadata.dependencies:
            if not self.is_dependency_available(dep_skill):
                raise DependencyUnavailableError(
                    f"Dependency skill {dep_skill} is not available"
                )
        
        return True
    
    def get_compensation_action(self) -> Optional[callable]:
        """è¿”å›è¡¥å¿åŠ¨ä½œ"""
        return None  # å­ç±»å¯é‡å†™
```

#### 2.4.2 æ ¸å¿ƒæŠ€èƒ½å®ç°ç¤ºä¾‹

**ç¤ºä¾‹1: è®¢å•æŸ¥è¯¢æŠ€èƒ½**

```python
class GetOrderDetailsSkill(BaseSkill):
    def __init__(self):
        metadata = SkillMetadata(
            skill_id="get_order_details_v1",
            name="getOrderDetails",
            description="æŸ¥è¯¢è®¢å•è¯¦ç»†ä¿¡æ¯",
            version="1.0.0",
            category="order",
            input_schema={
                "type": "object",
                "properties": {
                    "order_id": {"type": "string"},
                    "user_id": {"type": "string"}  # ç”¨äºæƒé™éªŒè¯
                },
                "required": ["order_id", "user_id"]
            },
            output_schema={
                "type": "object",
                "properties": {
                    "order_id": {"type": "string"},
                    "status": {"type": "string"},
                    "items": {"type": "array"},
                    "total_amount": {"type": "number"},
                    "customer_email": {"type": "string"},
                    "tracking_number": {"type": "string"},
                    "estimated_delivery": {"type": "string"}
                }
            },
            required_permissions=["order:read"],
            dependencies=[],
            sla=SkillSLA(
                max_latency_ms=200,
                success_rate_threshold=0.999,
                concurrent_limit=1000
            )
        )
        super().__init__(metadata)
        self.order_service = OrderService()
        self.cache = RedisCache()
    
    async def execute(
        self, 
        params: Dict[str, Any],
        context: ExecutionContext
    ) -> Dict[str, Any]:
        order_id = params["order_id"]
        user_id = params["user_id"]
        
        # å°è¯•ä»ç¼“å­˜è·å–
        cache_key = f"order:{order_id}"
        if cached := await self.cache.get(cache_key):
            self.logger.info(f"Cache hit for order {order_id}")
            return cached
        
        # ä»æ•°æ®åº“æŸ¥è¯¢
        order = await self.order_service.get_by_id(order_id)
        
        if not order:
            raise OrderNotFoundError(f"Order {order_id} not found")
        
        # æƒé™æ£€æŸ¥: åªèƒ½æŸ¥è¯¢è‡ªå·±çš„è®¢å•æˆ–æœ‰ç®¡ç†å‘˜æƒé™
        if order.customer_id != user_id and not context.has_permission("order:read:all"):
            raise PermissionDeniedError(
                f"User {user_id} cannot access order {order_id}"
            )
        
        # è½¬æ¢ä¸ºè¾“å‡ºæ ¼å¼
        result = {
            "order_id": order.id,
            "status": order.status,
            "items": [item.to_dict() for item in order.items],
            "total_amount": order.total_amount,
            "customer_email": order.customer_email,
            "tracking_number": order.tracking_number,
            "estimated_delivery": order.estimated_delivery.isoformat()
        }
        
        # ç¼“å­˜ç»“æœ(TTL: 5åˆ†é’Ÿ)
        await self.cache.set(cache_key, result, ttl=300)
        
        return result
```

**ç¤ºä¾‹2: æ”¯ä»˜å¤„ç†æŠ€èƒ½**

```python
class ProcessPaymentSkill(BaseSkill):
    def __init__(self):
        metadata = SkillMetadata(
            skill_id="process_payment_v1",
            name="processPayment",
            description="å¤„ç†æ”¯ä»˜è¯·æ±‚",
            version="1.0.0",
            category="payment",
            input_schema={
                "type": "object",
                "properties": {
                    "order_id": {"type": "string"},
                    "amount": {"type": "number"},
                    "currency": {"type": "string"},
                    "payment_method": {"type": "string"},
                    "idempotency_key": {"type": "string"}
                },
                "required": ["order_id", "amount", "payment_method", "idempotency_key"]
            },
            output_schema={
                "type": "object",
                "properties": {
                    "transaction_id": {"type": "string"},
                    "status": {"type": "string"},
                    "paid_at": {"type": "string"}
                }
            },
            required_permissions=["payment:execute"],
            dependencies=["getOrderDetails"],
            sla=SkillSLA(
                max_latency_ms=5000,
                success_rate_threshold=0.9999,  # æ”¯ä»˜è¦æ±‚æé«˜æˆåŠŸç‡
                concurrent_limit=500
            )
        )
        super().__init__(metadata)
        self.payment_gateway = PaymentGateway()
        self.order_service = OrderService()
        self.audit_logger = AuditLogger()
    
    async def execute(
        self, 
        params: Dict[str, Any],
        context: ExecutionContext
    ) -> Dict[str, Any]:
        # å¹‚ç­‰æ€§æ£€æŸ¥(é˜²æ­¢é‡å¤æ‰£æ¬¾)
        idempotency_key = params["idempotency_key"]
        if existing := await self.check_existing_payment(idempotency_key):
            self.logger.warn(f"Duplicate payment attempt: {idempotency_key}")
            return existing
        
        order_id = params["order_id"]
        amount = params["amount"]
        
        try:
            # 1. éªŒè¯è®¢å•çŠ¶æ€
            order = await self.order_service.get_by_id(order_id)
            if order.status != "PENDING_PAYMENT":
                raise InvalidOrderStateError(
                    f"Order {order_id} is not in PENDING_PAYMENT state"
                )
            
            # 2. é‡‘é¢æ ¡éªŒ
            if abs(order.total_amount - amount) > 0.01:  # å…è®¸0.01è¯¯å·®
                raise AmountMismatchError(
                    f"Payment amount {amount} doesn't match order amount {order.total_amount}"
                )
            
            # 3. è°ƒç”¨æ”¯ä»˜ç½‘å…³
            payment_result = await self.payment_gateway.charge(
                amount=amount,
                currency=params.get("currency", "USD"),
                method=params["payment_method"],
                metadata={
                    "order_id": order_id,
                    "idempotency_key": idempotency_key
                }
            )
            
            # 4. æ›´æ–°è®¢å•çŠ¶æ€
            await self.order_service.update_status(
                order_id=order_id,
                status="PAID",
                payment_transaction_id=payment_result.transaction_id
            )
            
            # 5. è®°å½•å®¡è®¡æ—¥å¿—
            await self.audit_logger.log(
                action="PAYMENT_PROCESSED",
                user_id=context.user_id,
                resource_type="order",
                resource_id=order_id,
                details={
                    "transaction_id": payment_result.transaction_id,
                    "amount": amount,
                    "method": params["payment_method"]
                }
            )
            
            return {
                "transaction_id": payment_result.transaction_id,
                "status": "SUCCESS",
                "paid_at": datetime.now().isoformat()
            }
        
        except PaymentGatewayError as e:
            # æ”¯ä»˜ç½‘å…³é”™è¯¯,éœ€è¦äººå·¥ä»‹å…¥
            await self.create_payment_alert(order_id, str(e))
            raise
        
        except Exception as e:
            self.logger.error(f"Payment failed: {e}")
            raise
    
    def get_compensation_action(self) -> callable:
        """æ”¯ä»˜å¤±è´¥åçš„è¡¥å¿åŠ¨ä½œ: é€€æ¬¾"""
        async def refund_payment(context: CompensationContext):
            transaction_id = context.step_result.data["transaction_id"]
            await self.payment_gateway.refund(transaction_id)
            await self.order_service.update_status(
                order_id=context.params["order_id"],
                status="PAYMENT_FAILED"
            )
        return refund_payment
```

**ç¤ºä¾‹3: æ™ºèƒ½æ¨èæŠ€èƒ½**

```python
class GetRecommendationsSkill(BaseSkill):
    def __init__(self):
        metadata = SkillMetadata(
            skill_id="get_recommendations_v1",
            name="getRecommendations",
            description="è·å–ä¸ªæ€§åŒ–äº§å“æ¨è",
            version="1.0.0",
            category="marketing",
            input_schema={
                "type": "object",
                "properties": {
                    "user_id": {"type": "string"},
                    "context": {"type": "string"},  # "homepage", "cart", "post_purchase"
                    "limit": {"type": "integer", "default": 10}
                },
                "required": ["user_id"]
            },
            output_schema={
                "type": "object",
                "properties": {
                    "recommendations": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "product_id": {"type": "string"},
                                "score": {"type": "number"},
                                "reason": {"type": "string"}
                            }
                        }
                    }
                }
            },
            required_permissions=["marketing:read"],
            dependencies=["getCustomerProfile"],
            sla=SkillSLA(
                max_latency_ms=500,
                success_rate_threshold=0.99,
                concurrent_limit=2000
            )
        )
        super().__init__(metadata)
        self.vector_search = VectorSearchService()
        self.ml_model = RecommendationModel()
        self.customer_service = CustomerService()
    
    async def execute(
        self, 
        params: Dict[str, Any],
        context: ExecutionContext
    ) -> Dict[str, Any]:
        user_id = params["user_id"]
        limit = params.get("limit", 10)
        rec_context = params.get("context", "homepage")
        
        # 1. è·å–ç”¨æˆ·ç”»åƒ
        user_profile = await self.customer_service.get_profile(user_id)
        
        # 2. æ··åˆæ¨èç­–ç•¥
        recommendations = []
        
        # 2a. åŸºäºååŒè¿‡æ»¤
        cf_recs = await self.ml_model.collaborative_filtering(
            user_id=user_id,
            limit=limit
        )
        recommendations.extend(cf_recs)
        
        # 2b. åŸºäºå†…å®¹çš„å‘é‡ç›¸ä¼¼åº¦
        if user_profile.recent_views:
            content_recs = await self.vector_search.similar_products(
                product_ids=user_profile.recent_views[-5:],  # æœ€è¿‘5ä¸ªæµè§ˆ
                limit=limit
            )
            recommendations.extend(content_recs)
        
        # 2c. åŸºäºä¸Šä¸‹æ–‡çš„è§„åˆ™æ¨è
        if rec_context == "cart":
            # è´­ç‰©è½¦åœºæ™¯: æ¨èäº’è¡¥å•†å“
            cart_items = await self.get_cart_items(user_id)
            bundle_recs = await self.ml_model.bundle_recommendation(cart_items)
            recommendations.extend(bundle_recs)
        
        # 3. å»é‡å’Œé‡æ’åº
        unique_recs = self.deduplicate(recommendations)
        ranked_recs = self.rerank(unique_recs, user_profile, rec_context)
        
        # 4. ç”Ÿæˆè§£é‡Š
        for rec in ranked_recs[:limit]:
            rec["reason"] = self.generate_explanation(rec, user_profile, rec_context)
        
        return {
            "recommendations": ranked_recs[:limit],
            "user_segment": user_profile.segment,
            "strategy_used": ["collaborative_filtering", "content_based", "contextual"]
        }
```

#### 2.4.3 æŠ€èƒ½æ³¨å†Œä¸å‘ç°

```python
class SkillRegistry:
    """æŠ€èƒ½æ³¨å†Œè¡¨"""
    
    def __init__(self):
        self.skills: Dict[str, BaseSkill] = {}
        self.metadata_store = MetadataStore()
    
    def register(self, skill: BaseSkill):
        """æ³¨å†ŒæŠ€èƒ½"""
        skill_id = skill.metadata.skill_id
        
        # éªŒè¯æŠ€èƒ½
        self.validate_skill(skill)
        
        # æ£€æŸ¥ç‰ˆæœ¬å…¼å®¹æ€§
        if existing := self.skills.get(skill_id):
            self.check_backward_compatibility(existing, skill)
        
        # æ³¨å†Œåˆ°å†…å­˜
        self.skills[skill_id] = skill
        
        # æŒä¹…åŒ–å…ƒæ•°æ®
        self.metadata_store.save(skill.metadata)
        
        logger.info(f"Skill registered: {skill_id} v{skill.metadata.version}")
    
    def get(self, skill_name: str, version: Optional[str] = None) -> BaseSkill:
        """è·å–æŠ€èƒ½å®ä¾‹"""
        if version:
            skill_id = f"{skill_name}_{version}"
        else:
            skill_id = self.get_latest_version(skill_name)
        
        if skill_id not in self.skills:
            raise SkillNotFoundError(f"Skill {skill_name} not found")
        
        return self.skills[skill_id]
    
    def discover(self, 
                 category: Optional[str] = None,
                 capability: Optional[str] = None) -> List[SkillMetadata]:
        """å‘ç°æŠ€èƒ½"""
        results = []
        for skill in self.skills.values():
            if category and skill.metadata.category != category:
                continue
            if capability and capability not in skill.metadata.capabilities:
                continue
            results.append(skill.metadata)
        return results
```

### 2.5 èµ„æºæ³¨å†Œè¡¨ (Resource Registry - å®ç°)

```python
class ResourceRegistry:
    """ç»Ÿä¸€èµ„æºæ³¨å†Œè¡¨"""
    
    def __init__(self):
        self.resources: Dict[str, Resource] = {}
        self.secret_manager = SecretManager()
        self.access_controller = AccessController()
    
    def register_resource(self, resource: Resource):
        """æ³¨å†Œèµ„æº"""
        # éªŒè¯èµ„æºé…ç½®
        self.validate_resource(resource)
        
        # å­˜å‚¨èµ„æºå…ƒæ•°æ®
        self.resources[resource.id] = resource
        
        # åŠ å¯†å¹¶å­˜å‚¨å‡­æ®
        if resource.credentials:
            self.secret_manager.store(
                key=f"resource:{resource.id}:credentials",
                value=resource.credentials,
                encryption=True
            )
    
    def get_resource(self, resource_id: str, requester_id: str) -> Resource:
        """è·å–èµ„æº(å¸¦æƒé™æ£€æŸ¥)"""
        resource = self.resources.get(resource_id)
        
        if not resource:
            raise ResourceNotFoundError(f"Resource {resource_id} not found")
        
        # æƒé™æ£€æŸ¥
        if not self.access_controller.can_access(requester_id, resource_id):
            raise AccessDeniedError(
                f"User {requester_id} cannot access resource {resource_id}"
            )
        
        # åŠ¨æ€æ³¨å…¥å‡­æ®
        resource.credentials = self.secret_manager.retrieve(
            key=f"resource:{resource_id}:credentials"
        )
        
        return resource

class Resource(BaseModel):
    """èµ„æºå®šä¹‰"""
    id: str
    name: str
    type: str  # "database", "api", "file_storage", "message_queue"
    endpoint: str
    credentials: Optional[Dict[str, str]]
    capabilities: List[str]
    rate_limits: Dict[str, int]
    health_check_url: Optional[str]
    sla: ResourceSLA

# èµ„æºé…ç½®ç¤ºä¾‹
RESOURCES = {
    "customer_database": Resource(
        id="customer_db_primary",
        name="Customer Database (Primary)",
        type="database",
        endpoint="postgresql://customer-db-prod.internal:5432/customers",
        capabilities=["read", "write", "transaction"],
        rate_limits={"queries_per_second": 1000},
        health_check_url="http://customer-db-prod.internal:5432/health"
    ),
    "payment_gateway": Resource(
        id="stripe_payment_gateway",
        name="Stripe Payment Gateway",
        type="api",
        endpoint="https://api.stripe.com/v1",
        capabilities=["charge", "refund", "subscription"],
        rate_limits={"requests_per_second": 100},
        health_check_url="https://api.stripe.com/v1/health"
    ),
    "logistics_api": Resource(
        id="fedex_logistics",
        name="FedEx Logistics API",
        type="api",
        endpoint="https://apis.fedex.com/track/v1",
        capabilities=["track", "estimate_delivery"],
        rate_limits={"requests_per_minute": 300}
    )
}
```

---

## 3. å®Œæ•´ä¸šåŠ¡æµç¨‹ç¤ºä¾‹

### 3.1 ç«¯åˆ°ç«¯åœºæ™¯: å¤„ç†è®¢å•å»¶è¿ŸæŠ•è¯‰

**ç”¨æˆ·è¾“å…¥**: "æˆ‘çš„è®¢å•12345ä¸ºä»€ä¹ˆè¿˜æ²¡åˆ°?éƒ½ä¸€å‘¨äº†!"

**ç³»ç»Ÿæ‰§è¡Œæµç¨‹:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 1: æ„å›¾è¯†åˆ«                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Intent: QueryOrderStatus                                    â”‚
â”‚ Sentiment: NEGATIVE (frustrated)                            â”‚
â”‚ Entities: {order_id: "12345", timeframe: "1 week"}         â”‚
â”‚ Slots: {order_id: âœ“, user_id: âœ“}                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 2: SOPåŒ¹é…                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Matched SOP: handle_order_delay_v1                          â”‚
â”‚ Confidence: 0.95                                             â”‚
â”‚ Pre-conditions: âœ“ User has permission                       â”‚
â”‚                 âœ“ Order exists                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 3: æ‰§è¡ŒSOP (7ä¸ªæ­¥éª¤)                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 3.1 getOrderDetails                                          â”‚
â”‚     â†’ order_status: "SHIPPED"                                â”‚
â”‚     â†’ tracking_number: "1Z999AA10123456784"                  â”‚
â”‚     â†’ estimated_delivery: "2024-01-20"                       â”‚
â”‚                                                               â”‚
â”‚ 3.2 queryLogistics                                           â”‚
â”‚     â†’ current_status: "IN_TRANSIT"                           â”‚
â”‚     â†’ last_scan: "2024-01-19 Denver, CO"                    â”‚
â”‚     â†’ delay_reason: "Weather conditions"                     â”‚
â”‚     â†’ new_estimated_delivery: "2024-01-23"                   â”‚
â”‚                                                               â”‚
â”‚ 3.3 Decision: IS_DELAYED? YES                                â”‚
â”‚     â†’ Days delayed: 3                                        â”‚
â”‚     â†’ Proceed to apology path                                â”‚
â”‚                                                               â”‚
â”‚ 3.4 generateCustomerApology (LLM Call)                       â”‚
â”‚     â†’ Model: claude-sonnet-4 (complex_generation policy)    â”‚
â”‚     â†’ Generated: "We sincerely apologize for the delay..."  â”‚
â”‚                                                               â”‚
â”‚ 3.5 offerCompensation                                        â”‚
â”‚     â†’ Policy: standard_delay_v1                              â”‚
â”‚     â†’ Compensation: 15% off coupon ($12.50)                  â”‚
â”‚     â†’ Coupon code: "SORRY2024XYZ"                            â”‚
â”‚                                                               â”‚
â”‚ 3.6 sendEmail                                                â”‚
â”‚     â†’ Sent to: customer@example.com                          â”‚
â”‚     â†’ Template: order_delay_notify_v2                        â”‚
â”‚     â†’ Status: SUCCESS                                        â”‚
â”‚                                                               â”‚
â”‚ 3.7 createSupportTicket (Async)                              â”‚
â”‚     â†’ Ticket ID: #CS-2024-001234                             â”‚
â”‚     â†’ Priority: MEDIUM                                       â”‚
â”‚     â†’ Assigned to: Support Team                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 4: ç”Ÿæˆç”¨æˆ·å“åº”                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ "æ‚¨çš„è®¢å• 12345 ç¡®å®é‡åˆ°äº†ç‰©æµå»¶è¿Ÿ,éå¸¸æŠ±æ­‰!                 â”‚
â”‚                                                               â”‚
â”‚ ğŸ“¦ å½“å‰çŠ¶æ€: è¿è¾“é€”ä¸­ (æœ€åæ‰«æ: Denver, CO)                 â”‚
â”‚ ğŸ“… é¢„è®¡é€è¾¾: 2024å¹´1æœˆ23æ—¥                                   â”‚
â”‚ ğŸŒ§ï¸  å»¶è¿ŸåŸå› : æ¶åŠ£å¤©æ°”å½±å“                                   â”‚
â”‚                                                               â”‚
â”‚ ä½œä¸ºè¡¥å¿,æˆ‘ä»¬å·²ç»:                                            â”‚
â”‚ âœ… å‘æ‚¨å‘é€äº†è¯¦ç»†çš„é“æ­‰é‚®ä»¶                                   â”‚
â”‚ ğŸ æä¾›äº†15%ä¼˜æƒ åˆ¸(ä»·å€¼$12.50): SORRY2024XYZ                â”‚
â”‚ ğŸ“‹ åˆ›å»ºäº†è·Ÿè¿›å·¥å• #CS-2024-001234                            â”‚
â”‚                                                               â”‚
â”‚ æˆ‘ä»¬ä¼šæŒç»­ç›‘æ§æ‚¨çš„è®¢å•,å¦‚æœ‰è¿›ä¸€æ­¥é—®é¢˜è¯·éšæ—¶è”ç³»ã€‚"           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 5: å®¡è®¡è®°å½•                                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Execution ID: exec_20240120_xyz123                           â”‚
â”‚ SOP: handle_order_delay_v1                                   â”‚
â”‚ Duration: 2.3 seconds                                        â”‚
â”‚ Status: SUCCESS                                              â”‚
â”‚ Cost: $0.023 (LLM: $0.020, Skills: $0.003)                  â”‚
â”‚ Models used: claude-sonnet-4 (1 call)                       â”‚
â”‚ Skills called: 6                                             â”‚
â”‚ User satisfaction predicted: 0.82                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 å¼‚å¸¸å¤„ç†åœºæ™¯: æ”¯ä»˜å¤±è´¥è¡¥å¿

**åœºæ™¯**: è®¢å•åˆ›å»ºæˆåŠŸ,ä½†æ”¯ä»˜ç¯èŠ‚å¤±è´¥

```yaml
SOP: create_order_with_payment

Steps:
  - id: create_order
    skill: createOrder
    status: SUCCESS âœ“
    result: {order_id: "67890", status: "PENDING_PAYMENT"}
  
  - id: reserve_inventory
    skill: reserveInventory
    status: SUCCESS âœ“
    result: {reserved: true, reservation_id: "res_123"}
  
  - id: process_payment
    skill: processPayment
    status: FAILED âœ—
    error: "Payment gateway timeout"
  
  # è§¦å‘SAGAè¡¥å¿æµç¨‹
  
Compensation Flow:
  - id: compensate_inventory
    action: releaseInventoryReservation
    params: {reservation_id: "res_123"}
    status: SUCCESS âœ“
  
  - id: compensate_order
    action: cancelOrder
    params: {order_id: "67890", reason: "payment_failed"}
    status: SUCCESS âœ“
  
  - id: notify_user
    action: sendEmail
    template: "payment_failed_notification"
    status: SUCCESS âœ“

Final Result:
  status: COMPENSATED
  user_message: "æŠ±æ­‰,æ”¯ä»˜å¤„ç†å¤±è´¥ã€‚æˆ‘ä»¬å·²å–æ¶ˆè®¢å•å¹¶é‡Šæ”¾åº“å­˜ã€‚è¯·é‡è¯•æˆ–è”ç³»å®¢æœã€‚"
  ticket_created: #CS-2024-001235
```

---

## 4. é«˜çº§ç‰¹æ€§

### 4.1 å¤šè½®å¯¹è¯ç®¡ç†

```python
class MultiTurnDialogueManager:
    """å¤šè½®å¯¹è¯ç®¡ç†å™¨"""
    
    def __init__(self):
        self.session_manager = SessionManager()
        self.context_builder = ContextBuilder()
    
    async def handle_message(
        self, 
        user_id: str, 
        message: str,
        session_id: Optional[str] = None
    ) -> Response:
        # 1. è·å–æˆ–åˆ›å»ºä¼šè¯
        if session_id:
            session = await self.session_manager.get(session_id)
        else:
            session = await self.session_manager.create(user_id)
        
        # 2. æ›´æ–°ä¼šè¯å†å²
        session.history.append(Message(
            role="user",
            content=message,
            timestamp=datetime.now()
        ))
        
        # 3. æ„å»ºå¢å¼ºä¸Šä¸‹æ–‡
        enriched_context = await self.context_builder.build(
            current_message=message,
            history=session.history[-10:],  # æœ€è¿‘10è½®
            user_profile=session.user_profile,
            current_sop=session.current_sop
        )
        
        # 4. å¤„ç†ä¸åŒä¼šè¯çŠ¶æ€
        if session.state == SessionStateEnum.COLLECTING_INFO:
            return await self.handle_slot_filling(session, message, enriched_context)
        
        elif session.state == SessionStateEnum.WAITING_CONFIRMATION:
            return await self.handle_confirmation(session, message)
        
        elif session.state == SessionStateEnum.EXECUTING:
            return await self.handle_execution_status(session)
        
        else:  # IDLE
            return await self.handle_new_intent(session, message, enriched_context)
    
    async def handle_slot_filling(
        self, 
        session: SessionState,
        message: str,
        context: EnrichedContext
    ) -> Response:
        """å¤„ç†æ§½ä½å¡«å……é˜¶æ®µ"""
        pending_slot = session.pending_slots[0]
        
        # æå–æ§½ä½å€¼
        slot_value = await self.extract_slot_value(
            slot_name=pending_slot,
            user_input=message,
            context=context
        )
        
        if slot_value:
            # å¡«å……æ§½ä½
            session.current_intent.slots[pending_slot] = slot_value
            session.pending_slots.pop(0)
            
            # æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å¾…å¡«å……æ§½ä½
            if not session.pending_slots:
                # æ‰€æœ‰æ§½ä½å·²å¡«å……,å¼€å§‹æ‰§è¡Œ
                session.state = SessionStateEnum.EXECUTING
                return await self.start_sop_execution(session)
            else:
                # ç»§ç»­è¯¢é—®ä¸‹ä¸€ä¸ªæ§½ä½
                next_slot = session.pending_slots[0]
                question = self.generate_slot_question(next_slot)
                return Response(
                    message=question,
                    session_state=session.state,
                    requires_user_input=True
                )
        else:
            # æœªèƒ½æå–æ§½ä½å€¼,é‡æ–°è¯¢é—®
            clarification = self.generate_clarification_question(pending_slot, message)
            return Response(
                message=clarification,
                session_state=session.state,
                requires_user_input=True
            )
    
    async def handle_confirmation(
        self, 
        session: SessionState,
        message: str
    ) -> Response:
        """å¤„ç†ç¡®è®¤é˜¶æ®µ"""
        confirmation = await self.parse_confirmation(message)
        
        if confirmation == "YES":
            # ç”¨æˆ·ç¡®è®¤,ç»§ç»­æ‰§è¡Œ
            session.state = SessionStateEnum.EXECUTING
            return await self.continue_sop_execution(session)
        
        elif confirmation == "NO":
            # ç”¨æˆ·æ‹’ç»,å–æ¶ˆæ“ä½œ
            session.state = SessionStateEnum.IDLE
            session.current_sop = None
            return Response(
                message="å¥½çš„,å·²å–æ¶ˆæ“ä½œã€‚è¿˜æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®æ‚¨çš„å—?",
                session_state=session.state
            )
        
        else:
            # æœªè¯†åˆ«,é‡æ–°è¯¢é—®
            return Response(
                message="è¯·ç¡®è®¤æ˜¯å¦ç»§ç»­? (æ˜¯/å¦)",
                session_state=session.state,
                requires_user_input=True
            )
```

### 4.2 ä¸Šä¸‹æ–‡å¢å¼ºç­–ç•¥

```python
class ContextBuilder:
    """ä¸Šä¸‹æ–‡æ„å»ºå™¨"""
    
    async def build(
        self,
        current_message: str,
        history: List[Message],
        user_profile: UserProfile,
        current_sop: Optional[SOP]
    ) -> EnrichedContext:
        """æ„å»ºå¢å¼ºä¸Šä¸‹æ–‡"""
        
        # 1. å¯¹è¯å†å²æ‘˜è¦
        history_summary = await self.summarize_history(history)
        
        # 2. ç”¨æˆ·ç”»åƒä¿¡æ¯
        user_context = {
            "user_id": user_profile.id,
            "vip_level": user_profile.vip_level,
            "recent_orders": user_profile.recent_orders[-5:],
            "preferences": user_profile.preferences,
            "lifetime_value": user_profile.lifetime_value
        }
        
        # 3. æ—¶é—´ä¸Šä¸‹æ–‡
        temporal_context = {
            "current_time": datetime.now(),
            "user_timezone": user_profile.timezone,
            "business_hours": self.is_business_hours(),
            "peak_time": self.is_peak_time()
        }
        
        # 4. ä¸šåŠ¡ä¸Šä¸‹æ–‡
        business_context = {}
        if current_sop:
            business_context = {
                "sop_name": current_sop.name,
                "current_step": current_sop.current_step,
                "execution_state": current_sop.execution_state,
                "intermediate_results": current_sop.intermediate_results
            }
        
        # 5. ç³»ç»ŸçŠ¶æ€ä¸Šä¸‹æ–‡
        system_context = {
            "available_skills": await self.get_available_skills(),
            "system_load": await self.get_system_load(),
            "rate_limit_remaining": await self.get_rate_limit(user_profile.id)
        }
        
        return EnrichedContext(
            current_message=current_message,
            history_summary=history_summary,
            user_context=user_context,
            temporal_context=temporal_context,
            business_context=business_context,
            system_context=system_context
        )
    
    async def summarize_history(self, history: List[Message]) -> str:
        """ä½¿ç”¨LLMæ‘˜è¦å¯¹è¯å†å²"""
        if len(history) < 3:
            return ""  # å†å²è¾ƒçŸ­,ä¸éœ€è¦æ‘˜è¦
        
        # æ„å»ºæ‘˜è¦Prompt
        conversation_text = "\n".join([
            f"{msg.role}: {msg.content}" for msg in history
        ])
        
        prompt = f"""è¯·ç®€è¦æ€»ç»“ä»¥ä¸‹å¯¹è¯çš„å…³é”®ä¿¡æ¯:

{conversation_text}

æ‘˜è¦(ä»…åŒ…å«å…³é”®äº‹å®å’Œæ„å›¾,50å­—ä»¥å†…):"""
        
        summary = await self.llm_client.complete(
            prompt=prompt,
            model="claude-haiku",  # ä½¿ç”¨å¿«é€Ÿä¾¿å®œçš„æ¨¡å‹
            max_tokens=100
        )
        
        return summary
```

### 4.3 ä¸»åŠ¨æ¨èä¸é¢„æµ‹

```python
class ProactiveAssistant:
    """ä¸»åŠ¨å¼AIåŠ©æ‰‹"""
    
    async def analyze_user_behavior(
        self, 
        user_id: str,
        recent_actions: List[Action]
    ) -> List[Suggestion]:
        """åˆ†æç”¨æˆ·è¡Œä¸ºå¹¶ä¸»åŠ¨æä¾›å»ºè®®"""
        
        suggestions = []
        
        # 1. è®¢å•è¿½è¸ªæé†’
        if self.should_remind_order_tracking(recent_actions):
            order_reminder = await self.generate_order_reminder(user_id)
            suggestions.append(order_reminder)
        
        # 2. è´­ç‰©è½¦é—å¼ƒæé†’
        if self.detect_cart_abandonment(recent_actions):
            cart_reminder = await self.generate_cart_reminder(user_id)
            suggestions.append(cart_reminder)
        
        # 3. ä¸ªæ€§åŒ–æ¨è
        if self.should_recommend_products(recent_actions):
            product_recs = await self.generate_recommendations(user_id)
            suggestions.append(product_recs)
        
        # 4. å®¢æœé—®é¢˜é¢„æµ‹
        if self.predict_support_need(recent_actions):
            support_offer = await self.generate_support_offer(user_id)
            suggestions.append(support_offer)
        
        return suggestions
    
    def detect_cart_abandonment(self, actions: List[Action]) -> bool:
        """æ£€æµ‹è´­ç‰©è½¦é—å¼ƒ"""
        # è§„åˆ™: 30åˆ†é’Ÿå†…æ·»åŠ è¿‡å•†å“åˆ°è´­ç‰©è½¦,ä½†æœªä¸‹å•
        added_to_cart = any(
            a.type == "ADD_TO_CART" and 
            (datetime.now() - a.timestamp).seconds < 1800
            for a in actions
        )
        
        checked_out = any(
            a.type == "CHECKOUT" and
            (datetime.now() - a.timestamp).seconds < 1800
            for a in actions
        )
        
        return added_to_cart and not checked_out
    
    async def generate_cart_reminder(self, user_id: str) -> Suggestion:
        """ç”Ÿæˆè´­ç‰©è½¦æé†’"""
        cart = await self.cart_service.get(user_id)
        
        # è®¡ç®—ä¼˜æƒ åŠ›åº¦
        discount = self.calculate_incentive(cart.total_value)
        
        return Suggestion(
            type="CART_REMINDER",
            priority="HIGH",
            message=f"æ‚¨çš„è´­ç‰©è½¦è¿˜æœ‰{len(cart.items)}ä»¶å•†å“ã€‚"
                    f"ç°åœ¨ä¸‹å•å¯äº«{discount}%ä¼˜æƒ !",
            cta="ç«‹å³æŸ¥çœ‹",
            action_url=f"/cart?user={user_id}",
            expires_at=datetime.now() + timedelta(hours=2)
        )
```

### 4.4 A/Bæµ‹è¯•æ¡†æ¶

```python
class ABTestingFramework:
    """A/Bæµ‹è¯•æ¡†æ¶"""
    
    async def assign_variant(
        self, 
        user_id: str,
        experiment_name: str
    ) -> str:
        """ä¸ºç”¨æˆ·åˆ†é…å®éªŒå˜ä½“"""
        experiment = await self.get_experiment(experiment_name)
        
        if not experiment.is_active:
            return experiment.control_variant
        
        # ä¸€è‡´æ€§å“ˆå¸Œç¡®ä¿åŒä¸€ç”¨æˆ·å§‹ç»ˆåˆ†é…åˆ°åŒä¸€å˜ä½“
        hash_value = hash(f"{user_id}:{experiment_name}")
        bucket = hash_value % 100
        
        cumulative = 0
        for variant, weight in experiment.variants.items():
            cumulative += weight
            if bucket < cumulative:
                return variant
        
        return experiment.control_variant
    
    async def execute_with_variant(
        self,
        user_id: str,
        experiment_name: str,
        control_fn: callable,
        variant_fn: callable
    ) -> Any:
        """æ ¹æ®åˆ†é…çš„å˜ä½“æ‰§è¡Œä¸åŒé€»è¾‘"""
        variant = await self.assign_variant(user_id, experiment_name)
        
        # è®°å½•å®éªŒåˆ†é…
        await self.log_assignment(user_id, experiment_name, variant)
        
        if variant == "control":
            result = await control_fn()
        else:
            result = await variant_fn()
        
        # è®°å½•å®éªŒç»“æœ
        await self.log_result(user_id, experiment_name, variant, result)
        
        return result

# ä½¿ç”¨ç¤ºä¾‹
async def recommend_products(user_id: str):
    ab_tester = ABTestingFramework()
    
    async def control():
        # æ§åˆ¶ç»„: ä¼ ç»Ÿæ¨èç®—æ³•
        return await traditional_recommend(user_id)
    
    async def variant():
        # å®éªŒç»„: AIé©±åŠ¨çš„æ¨è
        return await ai_recommend(user_id)
    
    recommendations = await ab_tester.execute_with_variant(
        user_id=user_id,
        experiment_name="ai_recommendation_v1",
        control_fn=control,
        variant_fn=variant
    )
    
    return recommendations
```

---

## 5. æ•°æ®æ¨¡å‹ä¸å®¡è®¡(è¯¦ç»†è®¾è®¡)

### 5.1 æ ¸å¿ƒæ•°æ®è¡¨

#### 5.1.1 AIå†³ç­–å®¡è®¡è¡¨

```sql
CREATE TABLE ai_decisions (
    -- ä¸»é”®
    decision_id VARCHAR(64) PRIMARY KEY,
    execution_id VARCHAR(64) NOT NULL,
    
    -- æ—¶é—´æˆ³
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    completed_at TIMESTAMP,
    
    -- ç”¨æˆ·ä¿¡æ¯
    user_id VARCHAR(64) NOT NULL,
    session_id VARCHAR(64),
    
    -- æ„å›¾ä¸SOP
    trigger_intent VARCHAR(128) NOT NULL,
    selected_sop_id VARCHAR(128) NOT NULL,
    sop_version VARCHAR(32),
    
    -- æ¨¡å‹ä¿¡æ¯
    model_used VARCHAR(64),
    model_router_policy VARCHAR(64),
    
    -- è¾“å…¥è¾“å‡º
    input_context JSONB NOT NULL,
    output_decision JSONB,
    
    -- è´¨é‡æŒ‡æ ‡
    confidence_score DECIMAL(5,4),
    execution_duration_ms INT,
    
    -- çŠ¶æ€
    status VARCHAR(32) NOT NULL,  -- SUCCESS, FAILED, COMPENSATED, PARTIAL
    error_message TEXT,
    
    -- æˆæœ¬
    total_cost_usd DECIMAL(10,6),
    llm_cost_usd DECIMAL(10,6),
    skill_cost_usd DECIMAL(10,6),
    
    -- å®¡è®¡
    compensated BOOLEAN DEFAULT FALSE,
    compensation_reason TEXT,
    human_reviewed BOOLEAN DEFAULT FALSE,
    reviewer_id VARCHAR(64),
    
    -- ç´¢å¼•
    INDEX idx_user_created (user_id, created_at),
    INDEX idx_sop_created (selected_sop_id, created_at),
    INDEX idx_status (status),
    INDEX idx_model (model_used)
);

-- åˆ†åŒºç­–ç•¥(æŒ‰æœˆåˆ†åŒº)
CREATE TABLE ai_decisions_y2024m01 PARTITION OF ai_decisions
FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
```

#### 5.1.2 ä¼šè¯çŠ¶æ€è¡¨

```sql
CREATE TABLE session_states (
    session_id VARCHAR(64) PRIMARY KEY,
    user_id VARCHAR(64) NOT NULL,
    
    -- çŠ¶æ€
    state VARCHAR(32) NOT NULL,  -- IDLE, COLLECTING_INFO, EXECUTING, etc.
    current_sop_id VARCHAR(128),
    current_step INT,
    
    -- ä¸Šä¸‹æ–‡
    context JSONB NOT NULL,
    history JSONB,  -- å¯¹è¯å†å²
    pending_slots JSONB,
    
    -- æ—¶é—´
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    last_active_at TIMESTAMP NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMP NOT NULL,
    
    -- ç´¢å¼•
    INDEX idx_user_active (user_id, last_active_at),
    INDEX idx_expires (expires_at)
);
```

#### 5.1.3 æŠ€èƒ½æ‰§è¡Œæ—¥å¿—è¡¨

```sql
CREATE TABLE skill_execution_logs (
    log_id VARCHAR(64) PRIMARY KEY,
    execution_id VARCHAR(64) NOT NULL,
    decision_id VARCHAR(64) NOT NULL,
    
    -- æŠ€èƒ½ä¿¡æ¯
    skill_id VARCHAR(128) NOT NULL,
    skill_version VARCHAR(32),
    
    -- æ‰§è¡Œä¿¡æ¯
    started_at TIMESTAMP NOT NULL,
    completed_at TIMESTAMP,
    duration_ms INT,
    
    -- è¾“å…¥è¾“å‡º
    input_params JSONB,
    output_result JSONB,
    
    -- çŠ¶æ€
    status VARCHAR(32) NOT NULL,
    error_code VARCHAR(64),
    error_message TEXT,
    retry_count INT DEFAULT 0,
    
    -- èµ„æºä½¿ç”¨
    resources_used JSONB,
    
    -- å¤–é”®
    FOREIGN KEY (decision_id) REFERENCES ai_decisions(decision_id),
    
    -- ç´¢å¼•
    INDEX idx_execution (execution_id),
    INDEX idx_skill_time (skill_id, started_at),
    INDEX idx_status (status)
);
```

### 5.2 å®¡è®¡æŸ¥è¯¢ç¤ºä¾‹

```sql
-- æŸ¥è¯¢æŸç”¨æˆ·çš„æ‰€æœ‰AIå†³ç­–å†å²
SELECT 
    d.decision_id,
    d.created_at,
    d.trigger_intent,
    d.selected_sop_id,
    d.model_used,
    d.status,
    d.total_cost_usd,
    d.execution_duration_ms
FROM ai_decisions d
WHERE d.user_id = 'user_12345'
ORDER BY d.created_at DESC
LIMIT 50;

-- åˆ†ææŸä¸ªSOPçš„æˆåŠŸç‡å’Œå¹³å‡è€—æ—¶
SELECT 
    selected_sop_id,
    COUNT(*) as total_executions,
    SUM(CASE WHEN status = 'SUCCESS' THEN 1 ELSE 0 END)::FLOAT / COUNT(*) as success_rate,
    AVG(execution_duration_ms) as avg_duration_ms,
    SUM(total_cost_usd) as total_cost
FROM ai_decisions
WHERE created_at >= NOW() - INTERVAL '30 days'
GROUP BY selected_sop_id
ORDER BY total_executions DESC;

-- æŸ¥è¯¢éœ€è¦äººå·¥å®¡æ ¸çš„å†³ç­–
SELECT 
    d.decision_id,
    d.user_id,
    d.selected_sop_id,
    d.created_at,
    d.confidence_score,
    d.input_context,
    d.output_decision
FROM ai_decisions d
WHERE d.human_reviewed = FALSE
  AND (
    d.confidence_score < 0.7  -- ä½ç½®ä¿¡åº¦
    OR d.total_cost_usd > 1.0  -- é«˜æˆæœ¬
    OR d.status = 'COMPENSATED'  -- å‘ç”Ÿè¡¥å¿
  )
ORDER BY d.created_at DESC;

-- åˆ†ææ¨¡å‹ä½¿ç”¨æˆæœ¬å’Œæ•ˆæœ
SELECT 
    model_used,
    COUNT(*) as usage_count,
    AVG(execution_duration_ms) as avg_latency,
    SUM(llm_cost_usd) as total_llm_cost,
    AVG(confidence_score) as avg_confidence,
    SUM(CASE WHEN status = 'SUCCESS' THEN 1 ELSE 0 END)::FLOAT / COUNT(*) as success_rate
FROM ai_decisions
WHERE created_at >= NOW() - INTERVAL '7 days'
GROUP BY model_used
ORDER BY usage_count DESC;
```

### 5.3 å®æ—¶ç›‘æ§ä»ªè¡¨æ¿

```python
class MonitoringDashboard:
    """å®æ—¶ç›‘æ§ä»ªè¡¨æ¿"""
    
    async def get_metrics(self, timeframe: str = "1h") -> Dict[str, Any]:
        """è·å–å…³é”®æŒ‡æ ‡"""
        
        metrics = {}
        
        # 1. ç³»ç»Ÿå¥åº·åº¦
        metrics["system_health"] = {
            "ai_orchestrator": await self.check_orchestrator_health(),
            "skill_services": await self.check_skills_health(),
            "databases": await self.check_databases_health(),
            "external_apis": await self.check_external_apis_health()
        }
        
        # 2. ä¸šåŠ¡æŒ‡æ ‡
        metrics["business_kpis"] = {
            "total_sessions": await self.count_sessions(timeframe),
            "active_users": await self.count_active_users(timeframe),
            "completed_tasks": await self.count_completed_tasks(timeframe),
            "automation_rate": await self.calc_automation_rate(timeframe),
            "user_satisfaction": await self.calc_satisfaction_score(timeframe)
        }
        
        # 3. AIæ€§èƒ½æŒ‡æ ‡
        metrics["ai_performance"] = {
            "intent_recognition_accuracy": await self.calc_intent_accuracy(timeframe),
            "sop_success_rate": await self.calc_sop_success_rate(timeframe),
            "avg_execution_time": await self.calc_avg_execution_time(timeframe),
            "compensation_rate": await self.calc_compensation_rate(timeframe)
        }
        
        # 4. æˆæœ¬æŒ‡æ ‡
        metrics["cost_metrics"] = {
            "total_cost": await self.calc_total_cost(timeframe),
            "llm_cost": await self.calc_llm_cost(timeframe),
            "cost_per_task": await self.calc_cost_per_task(timeframe),
            "cost_by_model": await self.get_cost_by_model(timeframe)
        }
        
        # 5. å‘Šè­¦ä¿¡æ¯
        metrics["alerts"] = await self.get_active_alerts()
        
        return metrics
    
    async def get_active_alerts(self) -> List[Alert]:
        """è·å–æ´»è·ƒå‘Šè­¦"""
        alerts = []
        
        # æ£€æŸ¥æˆåŠŸç‡å‘Šè­¦
        success_rate = await self.calc_sop_success_rate("1h")
        if success_rate < 0.95:
            alerts.append(Alert(
                severity="WARNING",
                title="SOPæˆåŠŸç‡ä½äºé˜ˆå€¼",
                message=f"å½“å‰æˆåŠŸç‡: {success_rate:.2%}, é˜ˆå€¼: 95%",
                timestamp=datetime.now()
            ))
        
        # æ£€æŸ¥æˆæœ¬å‘Šè­¦
        hourly_cost = await self.calc_total_cost("1h")
        if hourly_cost > 100:  # $100/hour
            alerts.append(Alert(
                severity="CRITICAL",
                title="æˆæœ¬è¶…å‡ºé¢„ç®—",
                message=f"å½“å‰å°æ—¶æˆæœ¬: ${hourly_cost:.2f}, é¢„ç®—: $100",
                timestamp=datetime.now()
            ))
        
        # æ£€æŸ¥å»¶è¿Ÿå‘Šè­¦
        avg_latency = await self.calc_avg_execution_time("5m")
        if avg_latency > 5000:  # 5ç§’
            alerts.append(Alert(
                severity="WARNING",
                title="æ‰§è¡Œå»¶è¿Ÿè¿‡é«˜",
                message=f"å¹³å‡å»¶è¿Ÿ: {avg_latency}ms, é˜ˆå€¼: 5000ms",
                timestamp=datetime.now()
            ))
        
        return alerts
```

---

## 6. éƒ¨ç½²ä¸å®æ–½(è¯¦ç»†Roadmap)

### 6.1 Phase 0: æ¦‚å¿µéªŒè¯ (4-6å‘¨)

**ç›®æ ‡**: éªŒè¯æ ¸å¿ƒæŠ€æœ¯å¯è¡Œæ€§

**äº¤ä»˜ç‰©**:
1. æœ€å°åŒ–Orchestrator(Python FastAPI)
2. 2-3ä¸ªæ ¸å¿ƒSkill(getOrderDetails, queryLogistics)
3. 1ä¸ªå®Œæ•´SOP(handle_order_delay)
4. åŸºç¡€ç›‘æ§(æ—¥å¿—è®°å½•)

**æŠ€æœ¯æ ˆ**:
- Backend: FastAPI + PostgreSQL
- LLM: Claude Sonnet 4 (API)
- Deployment: å•æœºDockeréƒ¨ç½²

**éªŒæ”¶æ ‡å‡†**:
- [ ] èƒ½å¤Ÿé€šè¿‡è‡ªç„¶è¯­è¨€è§¦å‘SOPæ‰§è¡Œ
- [ ] æˆåŠŸå®Œæˆç«¯åˆ°ç«¯è®¢å•æŸ¥è¯¢æµç¨‹
- [ ] ai_decisionsè¡¨æ­£ç¡®è®°å½•æ‰€æœ‰å†³ç­–
- [ ] å¹³å‡å“åº”æ—¶é—´ < 3ç§’

### 6.2 Phase 1: MVP (3ä¸ªæœˆ)

**ç›®æ ‡**: æ ¸å¿ƒä¸šåŠ¡åœºæ™¯ä¸Šçº¿

**åŠŸèƒ½èŒƒå›´**:
- å®¢æˆ·ç®¡ç†: å®¢æˆ·æŸ¥è¯¢ã€å®¢æˆ·ç”»åƒ
- è®¢å•å¤„ç†: è®¢å•æŸ¥è¯¢ã€è®¢å•ä¿®æ”¹ã€é€€æ¬¾å¤„ç†
- å®¢æˆ·æœåŠ¡: å·¥å•åˆ›å»ºã€è‡ªåŠ¨å›å¤

**æ–°å¢ç»„ä»¶**:
- Session Manager(å¤šè½®å¯¹è¯)
- Intent Recognizer(æ„å›¾è¯†åˆ«)
- Model Router(æ¨¡å‹è·¯ç”±)
- Skill Registry(æŠ€èƒ½æ³¨å†Œè¡¨)
- 3-5ä¸ªé¢å¤–Skills
- 5-8ä¸ªSOPs

**æŠ€æœ¯å‡çº§**:
- Kuberneteséƒ¨ç½²(GKE)
- Redis(ä¼šè¯ç®¡ç†)
- Vector Search(è¯­ä¹‰æ£€ç´¢)
- Prometheus + Grafana(ç›‘æ§)

**ä¸Šçº¿ç­–ç•¥**:
1. **å½±å­æ¨¡å¼**(2å‘¨): AIå¹¶è¡Œè¿è¡Œä½†ä¸å®é™…æ‰§è¡Œ,å¯¹æ¯”ç»“æœ
2. **é‡‘ä¸é›€å‘å¸ƒ**(2å‘¨): 5%å‘˜å·¥ä½¿ç”¨,å¯†åˆ‡ç›‘æ§
3. **é€æ­¥æ¨å¹¿**(4å‘¨): 25% â†’ 50% â†’ 100%

**éªŒæ”¶æ ‡å‡†**:
- [ ] æ„å›¾è¯†åˆ«å‡†ç¡®ç‡ > 90%
- [ ] SOPæ‰§è¡ŒæˆåŠŸç‡ > 95%
- [ ] ç”¨æˆ·æ»¡æ„åº¦ > 4.0/5.0
- [ ] æ‰‹åŠ¨æ“ä½œå‡å°‘ > 60%
- [ ] å¹³å‡å“åº”æ—¶é—´ < 2ç§’

### 6.3 Phase 2: å…¨é“¾è·¯è¦†ç›– (3-6ä¸ªæœˆ)

**ç›®æ ‡**: æ‰©å±•åˆ°æ‰€æœ‰ä¸šåŠ¡åœºæ™¯

**æ–°å¢æ¨¡å—**:
- åº“å­˜ç‰©æµç®¡ç†
- è¥é”€è‡ªåŠ¨åŒ–
- æ•°æ®åˆ†æä¸æŠ¥è¡¨
- æ”¯ä»˜ç»“ç®—

**é«˜çº§ç‰¹æ€§**:
- SAGAè¡¥å¿æœºåˆ¶
- äººå·¥å®¡æ‰¹æµç¨‹
- A/Bæµ‹è¯•æ¡†æ¶
- ä¸»åŠ¨æ¨èç³»ç»Ÿ
- å¤šè¯­è¨€æ”¯æŒ

**æŠ€æœ¯å¢å¼º**:
- Data Lake(BigQuery)
- Workflow Engine(Temporal)
- Service Mesh(Istio)
- åˆ†å¸ƒå¼è¿½è¸ª(Jaeger)

**éªŒæ”¶æ ‡å‡†**:
- [ ] è¦†ç›–80%+å¸¸è§ä¸šåŠ¡åœºæ™¯
- [ ] æ‰‹åŠ¨æ“ä½œå‡å°‘ > 80%
- [ ] ç³»ç»Ÿå¯ç”¨æ€§ > 99.9%
- [ ] æˆæœ¬æ§åˆ¶åœ¨é¢„ç®—å†…

### 6.4 Phase 3: æ™ºèƒ½ä¼˜åŒ– (æŒç»­)

**ä¼˜åŒ–æ–¹å‘**:
1. **æˆæœ¬ä¼˜åŒ–**
   - Prompt Caching
   - æ··åˆæ¨¡å‹ç­–ç•¥(æœ¬åœ°+äº‘ç«¯)
   - æ™ºèƒ½è·¯ç”±ä¼˜åŒ–

2. **æ€§èƒ½ä¼˜åŒ–**
   - è¾¹ç¼˜è®¡ç®—
   - é¢„æµ‹æ€§ç¼“å­˜
   - å¹¶è¡Œæ‰§è¡Œä¼˜åŒ–

3. **æ™ºèƒ½æå‡**
   - åŸºäºåé¦ˆçš„æŒç»­å­¦ä¹ 
   - è‡ªåŠ¨SOPä¼˜åŒ–
   - å¼‚å¸¸æ¨¡å¼è¯†åˆ«

---

## 7. é£é™©ç®¡ç†ä¸ç¼“è§£

### 7.1 æŠ€æœ¯é£é™©

| é£é™© | å½±å“ | æ¦‚ç‡ | ç¼“è§£æªæ–½ |
|-----|------|-----|---------|
| AIå¹»è§‰/é”™è¯¯å†³ç­– | é«˜ | ä¸­ | 1. SOPå¼ºçº¦æŸ<br>2. å…³é”®å†³ç­–äººå·¥å®¡æ‰¹<br>3. ç½®ä¿¡åº¦é˜ˆå€¼<br>4. å®æ—¶ç›‘æ§ä¸å‘Šè­¦ |
| ç³»ç»Ÿæ€§èƒ½ç“¶é¢ˆ | ä¸­ | ä¸­ | 1. æ°´å¹³æ‰©å±•è®¾è®¡<br>2. ç¼“å­˜ç­–ç•¥<br>3. å¼‚æ­¥å¤„ç†<br>4. é™æµä¸é™çº§ |
| ç¬¬ä¸‰æ–¹APIä¸å¯ç”¨ | é«˜ | ä½ | 1. å¤šä¾›åº”å•†å¤‡ä»½<br>2. ç†”æ–­æœºåˆ¶<br>3. é™çº§æ–¹æ¡ˆ<br>4. SLAä¿éšœ |
| æ•°æ®ä¸€è‡´æ€§é—®é¢˜ | é«˜ | ä½ | 1. SAGAè¡¥å¿æœºåˆ¶<br>2. å¹‚ç­‰æ€§è®¾è®¡<br>3. åˆ†å¸ƒå¼äº‹åŠ¡<br>4. å¯¹è´¦æœºåˆ¶ |

### 7.2 ä¸šåŠ¡é£é™©

| é£é™© | å½±å“ | æ¦‚ç‡ | ç¼“è§£æªæ–½ |
|-----|------|-----|---------|
| ç”¨æˆ·æ¥å—åº¦ä½ | é«˜ | ä¸­ | 1. å……åˆ†åŸ¹è®­<br>2. æ¸è¿›å¼æ¨å¹¿<br>3. ä¿ç•™æ‰‹åŠ¨æ¨¡å¼<br>4. æ”¶é›†åé¦ˆå¿«é€Ÿè¿­ä»£ |
| æˆæœ¬è¶…æ”¯ | ä¸­ | ä¸­ | 1. ä¸¥æ ¼é¢„ç®—æ§åˆ¶<br>2. å®æ—¶æˆæœ¬ç›‘æ§<br>3. æ¨¡å‹è·¯ç”±ä¼˜åŒ–<br>4. ç¼“å­˜ç­–ç•¥ |
| åˆè§„æ€§é—®é¢˜ | é«˜ | ä½ | 1. å®Œæ•´å®¡è®¡æ—¥å¿—<br>2. æ•°æ®åŠ å¯†<br>3. æƒé™æ§åˆ¶<br>4. å®šæœŸåˆè§„å®¡æŸ¥ |
| ç«äº‰å¯¹æ‰‹è¶…è¶Š | ä¸­ | ä¸­ | 1. æŒç»­åˆ›æ–°<br>2. å¿«é€Ÿè¿­ä»£<br>3. å·®å¼‚åŒ–èƒ½åŠ›<br>4. æŠ€æœ¯å‚¨å¤‡ |

### 7.3 å®‰å…¨é£é™©

**æ•°æ®å®‰å…¨**:
```python
class DataSecurityManager:
    """æ•°æ®å®‰å…¨ç®¡ç†å™¨"""
    
    def encrypt_pii(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """åŠ å¯†ä¸ªäººèº«ä»½ä¿¡æ¯"""
        pii_fields = ["email", "phone", "address", "ssn"]
        
        for field in pii_fields:
            if field in data:
                data[field] = self.encrypt(data[field])
        
        return data
    
    def mask_sensitive_in_logs(self, log_data: str) -> str:
        """æ—¥å¿—ä¸­è„±æ•æ•æ„Ÿä¿¡æ¯"""
        patterns = {
            r'\b\d{16}\b': '****-****-****-****',  # ä¿¡ç”¨å¡å·
            r'\b\d{3}-\d{2}-\d{4}\b': '***-**-****',  # SSN
            r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b': '***@***.***'  # Email
        }
        
        for pattern, replacement in patterns.items():
            log_data = re.sub(pattern, replacement, log_data)
        
        return log_data
```

**è®¿é—®æ§åˆ¶**:
```python
# RBACæƒé™å®šä¹‰
PERMISSIONS = {
    "customer_service": [
        "order:read",
        "order:update",
        "customer:read",
        "ticket:create",
        "ticket:read"
    ],
    "manager": [
        "order:read",
        "order:update",
        "order:delete",
        "customer:read",
        "customer:update",
        "payment:read",
        "refund:execute"
    ],
    "admin": ["*"]  # æ‰€æœ‰æƒé™
}

class AccessController:
    def check_permission(
        self, 
        user_id: str, 
        required_permission: str
    ) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æƒé™"""
        user = self.get_user(user_id)
        user_permissions = PERMISSIONS.get(user.role, [])
        
        # é€šé…ç¬¦æƒé™
        if "*" in user_permissions:
            return True
        
        # ç²¾ç¡®åŒ¹é…
        if required_permission in user_permissions:
            return True
        
        # å±‚çº§åŒ¹é…(å¦‚ order:* åŒ…å« order:read)
        permission_prefix = required_permission.split(':')[0]
        if f"{permission_prefix}:*" in user_permissions:
            return True
        
        return False
```

---

## 8. æˆåŠŸæŒ‡æ ‡ä¸KPI

### 8.1 ä¸šåŠ¡æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡å€¼ | æµ‹é‡æ–¹æ³• |
|-----|--------|---------|
| ä¸šåŠ¡è‡ªåŠ¨åŒ–ç‡ | > 80% | (AIè‡ªåŠ¨å®Œæˆä»»åŠ¡æ•° / æ€»ä»»åŠ¡æ•°) Ã— 100% |
| æ‰‹åŠ¨æ“ä½œå‡å°‘ | > 80% | (åŸæ‰‹åŠ¨æ­¥éª¤æ•° - ç°æ‰‹åŠ¨æ­¥éª¤æ•°) / åŸæ‰‹åŠ¨æ­¥éª¤æ•° |
| å¤„ç†æ•ˆç‡æå‡ | > 30% | (åŸå¹³å‡å¤„ç†æ—¶é—´ - ç°å¹³å‡å¤„ç†æ—¶é—´) / åŸå¹³å‡å¤„ç†æ—¶é—´ |
| ç”¨æˆ·æ»¡æ„åº¦ | > 4.0/5.0 | ç”¨æˆ·è¯„åˆ†å¹³å‡å€¼ |
| é¦–æ¬¡è§£å†³ç‡ | > 85% | é¦–æ¬¡äº¤äº’è§£å†³é—®é¢˜çš„æ¯”ä¾‹ |

### 8.2 æŠ€æœ¯æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡å€¼ | æµ‹é‡æ–¹æ³• |
|-----|--------|---------|
| æ„å›¾è¯†åˆ«å‡†ç¡®ç‡ | > 92% | æ­£ç¡®è¯†åˆ«æ„å›¾æ•° / æ€»è¯·æ±‚æ•° |
| SOPæ‰§è¡ŒæˆåŠŸç‡ | > 95% | æˆåŠŸæ‰§è¡ŒSOPæ•° / æ€»æ‰§è¡Œæ•° |
| ç³»ç»Ÿå¯ç”¨æ€§ | > 99.9% | (æ€»æ—¶é—´ - æ•…éšœæ—¶é—´) / æ€»æ—¶é—´ |
| å¹³å‡å“åº”æ—¶é—´ | < 2ç§’ | P95å“åº”æ—¶é—´ |
| è¡¥å¿è§¦å‘ç‡ | < 2% | è§¦å‘è¡¥å¿çš„æ‰§è¡Œæ•° / æ€»æ‰§è¡Œæ•° |

### 8.3 æˆæœ¬æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡å€¼ | æµ‹é‡æ–¹æ³• |
|-----|--------|---------|
| å•æ¬¡ä»»åŠ¡æˆæœ¬ | < $0.10 | æ€»æˆæœ¬ / ä»»åŠ¡å®Œæˆæ•° |
| LLMæˆæœ¬å æ¯” | < 60% | LLMæˆæœ¬ / æ€»æˆæœ¬ |
| ROI | > 300% | (èŠ‚çœæˆæœ¬ - ç³»ç»Ÿæˆæœ¬) / ç³»ç»Ÿæˆæœ¬ |

### 8.4 ç›‘æ§ä»ªè¡¨æ¿ç¤ºä¾‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   AIä¸šåŠ¡åŠ©æ‰‹å®æ—¶ç›‘æ§                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  ç³»ç»Ÿå¥åº·åº¦: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ 92%                      â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚  ä»Šæ—¥ä»»åŠ¡æ•°      â”‚  â”‚  è‡ªåŠ¨åŒ–ç‡        â”‚  â”‚  ç”¨æˆ·æ»¡æ„åº¦  â”‚â”‚
â”‚  â”‚  2,847          â”‚  â”‚  87.3%          â”‚  â”‚  4.2/5.0    â”‚â”‚
â”‚  â”‚  â†‘ 12% vsæ˜¨å¤©   â”‚  â”‚  â†‘ 3.2%        â”‚  â”‚  â†‘ 0.1      â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                                               â”‚
â”‚  SOPæ‰§è¡Œæƒ…å†µ (æœ€è¿‘1å°æ—¶)                                      â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚  handle_order_delay        156æ¬¡  æˆåŠŸç‡: 97.4%  â–‚â–ƒâ–…â–‡â–ˆâ–‡â–…  â”‚
â”‚  process_refund             89æ¬¡  æˆåŠŸç‡: 98.9%  â–ƒâ–„â–†â–†â–†â–…â–ƒ  â”‚
â”‚  customer_inquiry          234æ¬¡  æˆåŠŸç‡: 95.3%  â–„â–†â–ˆâ–†â–…â–„â–ƒ  â”‚
â”‚                                                               â”‚
â”‚  æ¨¡å‹ä½¿ç”¨ç»Ÿè®¡                                                 â”‚
â”‚  claude-sonnet-4:  1,234æ¬¡  æˆæœ¬: $23.45  å»¶è¿Ÿ: 387ms       â”‚
â”‚  claude-haiku:      892æ¬¡  æˆæœ¬: $2.67   å»¶è¿Ÿ: 145ms       â”‚
â”‚                                                               â”‚
â”‚  æ´»è·ƒå‘Šè­¦ (2)                                                 â”‚
â”‚  âš ï¸  WARNING: è®¢å•æœåŠ¡å“åº”æ—¶é—´è¶…è¿‡500ms                      â”‚
â”‚  âš ï¸  WARNING: LLMæˆæœ¬å¢é•¿å¼‚å¸¸(+35% vs ä¸Šå‘¨)                 â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 9. é™„å½•

### 9.1 æ›´å¤šSOPç¤ºä¾‹

#### SOP: æ™ºèƒ½é€€æ¬¾å¤„ç†

```yaml
SOP_ID: process_intelligent_refund_v1
DESCRIPTION: "æ™ºèƒ½å¤„ç†é€€æ¬¾è¯·æ±‚,æ ¹æ®è®¢å•çŠ¶æ€å’Œç”¨æˆ·å†å²è‡ªåŠ¨å†³ç­–"

TRIGGERS:
  - type: user_intent
    intent_name: "RequestRefund"
  - type: user_intent
    intent_name: "ReportDefectiveProduct"

INPUT_SCHEMA:
  type: object
  properties:
    order_id: { type: "string" }
    reason: { type: "string" }
    user_id: { type: "string" }
  required: [order_id, reason, user_id]

STEPS:
  - id: validate_order
    type: skill_call
    skill_name: "getOrderDetails"
    input:
      order_id: "${INPUT.order_id}"
      user_id: "${INPUT.user_id}"
    output_var: "order"
    on_failure: goto: step_order_not_found
  
  - id: check_refund_eligibility
    type: skill_call
    skill_name: "checkRefundEligibility"
    input:
      order: "${order}"
      reason: "${INPUT.reason}"
    output_var: "eligibility"
  
  - id: get_user_history
    type: skill_call
    skill_name: "getUserRefundHistory"
    input:
      user_id: "${INPUT.user_id}"
    output_var: "user_history"
  
  - id: ai_decision
    type: model_call
    skill_name: "makeRefundDecision"
    model_router_policy: "financial_sensitive"
    prompt_template: |
      æ ¹æ®ä»¥ä¸‹ä¿¡æ¯å†³ç­–é€€æ¬¾:
      
      è®¢å•ä¿¡æ¯:
      - è®¢å•é‡‘é¢: ${order.total_amount}
      - è®¢å•æ—¥æœŸ: ${order.order_date}
      - è®¢å•çŠ¶æ€: ${order.status}
      
      é€€æ¬¾åŸå› : ${INPUT.reason}
      
      ç”¨æˆ·å†å²:
      - æ€»è®¢å•æ•°: ${user_history.total_orders}
      - å†å²é€€æ¬¾æ¬¡æ•°: ${user_history.refund_count}
      - ç”¨æˆ·ç­‰çº§: ${user_history.vip_level}
      - ç”Ÿå‘½å‘¨æœŸä»·å€¼: ${user_history.lifetime_value}
      
      é€€æ¬¾èµ„æ ¼æ£€æŸ¥: ${eligibility.is_eligible}
      é™åˆ¶å› ç´ : ${eligibility.constraints}
      
      è¯·å†³ç­–:
      1. æ˜¯å¦æ‰¹å‡†é€€æ¬¾
      2. é€€æ¬¾é‡‘é¢(å¯ä»¥æ˜¯éƒ¨åˆ†é€€æ¬¾)
      3. æ˜¯å¦éœ€è¦é¢å¤–è¡¥å¿
      4. å†³ç­–ç†ç”±
      
      ä»¥JSONæ ¼å¼è¿”å›:
      {
        "approve": true/false,
        "refund_amount": æ•°å­—,
        "compensation": {
          "type": "coupon/credit",
          "value": æ•°å­—
        },
        "reason": "å†³ç­–ç†ç”±",
        "confidence": 0.0-1.0
      }
    output_var: "decision"
  
  - id: check_decision_confidence
    type: decision_logic
    condition: "${decision.confidence} < 0.8"
    true_path:
      - goto: step_request_human_approval
    false_path:
      - goto: step_execute_refund
  
  - id: step_request_human_approval
    type: human_approval
    message: |
      é€€æ¬¾å†³ç­–ç½®ä¿¡åº¦è¾ƒä½,éœ€è¦äººå·¥å®¡æ‰¹:
      
      è®¢å•: ${order.order_id}
      é‡‘é¢: $${order.total_amount}
      AIå»ºè®®: ${decision.approve ? "æ‰¹å‡†" : "æ‹’ç»"}
      ç½®ä¿¡åº¦: ${decision.confidence}
      ç†ç”±: ${decision.reason}
    approvers: ["refund_manager"]
    timeout: 3600  # 1å°æ—¶
    output_var: "human_decision"
  
  - id: step_execute_refund
    type: skill_call
    skill_name: "executeRefund"
    input:
      order_id: "${order.order_id}"
      amount: "${decision.refund_amount}"
      reason: "${decision.reason}"
      idempotency_key: "${EXECUTION_ID}_refund"
    output_var: "refund_result"
  
  - id: update_order_status
    type: skill_call
    skill_name: "updateOrderStatus"
    input:
      order_id: "${order.order_id}"
      status: "REFUNDED"
      refund_transaction_id: "${refund_result.transaction_id}"
  
  - id: send_notification
    type: parallel_execution
    steps:
      - id: email_customer
        type: skill_call
        skill_name: "sendEmail"
        input:
          recipient: "${order.customer_email}"
          template: "refund_approved"
          data:
            amount: "${decision.refund_amount}"
            reason: "${decision.reason}"
      
      - id: create_ticket
        type: skill_call
        skill_name: "createSupportTicket"
        input:
          user_id: "${INPUT.user_id}"
          type: "REFUND_PROCESSED"
          description: "é€€æ¬¾å·²å¤„ç†: ${order.order_id}"
  
  - id: offer_compensation
    type: decision_logic
    condition: "${decision.compensation} != null"
    true_path:
      - id: apply_compensation
        type: skill_call
        skill_name: "applyCompensation"
        input:
          user_id: "${INPUT.user_id}"
          compensation: "${decision.compensation}"
    false_path:
      - goto: step_success
  
  - id: step_success
    type: output
    message_template: |
      æ‚¨çš„é€€æ¬¾ç”³è¯·å·²æ‰¹å‡†!
      
      é€€æ¬¾é‡‘é¢: $${decision.refund_amount}
      å¤„ç†æ—¶é—´: 3-5ä¸ªå·¥ä½œæ—¥
      ${decision.compensation ? "é¢å¤–è¡¥å¿: " + decision.compensation.type + " $" + decision.compensation.value : ""}
      
      æ„Ÿè°¢æ‚¨çš„ç†è§£å’Œæ”¯æŒ!
    goto: step_end

COMPENSATION_STRATEGY:
  - step: step_execute_refund
    on_failure:
      - rollback: update_order_status
      - notify: refund_manager
      - create_alert: "REFUND_EXECUTION_FAILED"

AUDIT_POLICY:
  log_to: ai_decisions
  level: FULL_TRACE
  sensitive_data_mask: true
  human_review_required: true
```

### 9.2 æŠ€æœ¯æ ˆè¯¦ç»†å¯¹æ¯”

| ç»„ä»¶ | æ–¹æ¡ˆA(æ¨è) | æ–¹æ¡ˆB(å¤‡é€‰) | æ–¹æ¡ˆC(å¿«é€Ÿå¯åŠ¨) |
|-----|------------|------------|---------------|
| **äº‘å¹³å°** | GCP (Vertex AIç”Ÿæ€) | AWS (Bedrockç”Ÿæ€) | Azure (OpenAIæœåŠ¡) |
| **å®¹å™¨ç¼–æ’** | GKE (æ‰˜ç®¡K8s) | EKS | AKS |
| **å·¥ä½œæµå¼•æ“** | Temporal | AWS Step Functions | Airflow |
| **å‘é‡æ•°æ®åº“** | Vertex AI Vector Search | Pinecone | Weaviate |
| **äº‹ä»¶æ€»çº¿** | Google Pub/Sub | AWS EventBridge | Kafka |
| **ç›‘æ§** | Prometheus + Grafana | CloudWatch | Datadog |

### 9.3 å¼€å‘è§„èŒƒ

**ä»£ç é£æ ¼**:
- Python: PEP 8 + Black formatter
- TypeScript: ESLint + Prettier
- æ–‡æ¡£: Google docstring style

**Gitå·¥ä½œæµ**:
- Mainåˆ†æ”¯: ç”Ÿäº§ç¯å¢ƒ
- Developåˆ†æ”¯: å¼€å‘ç¯å¢ƒ
- Featureåˆ†æ”¯: åŠŸèƒ½å¼€å‘
- PRè¦æ±‚: è‡³å°‘2äººreview + æ‰€æœ‰æµ‹è¯•é€šè¿‡

**æµ‹è¯•è¦æ±‚**:
- å•å…ƒæµ‹è¯•è¦†ç›–ç‡: > 80%
- é›†æˆæµ‹è¯•: å…³é”®è·¯å¾„å¿…è¦†ç›–
- E2Eæµ‹è¯•: æ ¸å¿ƒä¸šåŠ¡æµç¨‹
- æ€§èƒ½æµ‹è¯•: æ¯æ¬¡å‘å¸ƒå‰æ‰§è¡Œ

---

## ç»“è¯­

è¿™ä»½ä¼˜åŒ–æ–¹æ¡ˆæä¾›äº†æ„å»º"çœŸæ­£èƒ½æ‰§è¡Œå®Œæ•´ä¸šåŠ¡æ“ä½œçš„AIåŠ©æ‰‹"çš„å®Œæ•´è“å›¾ã€‚å…³é”®æ”¹è¿›åŒ…æ‹¬:

âœ… **å®Œæ•´çš„å¯¹è¯ç®¡ç†**: å¤šè½®å¯¹è¯ã€ä¸Šä¸‹æ–‡ç»´æŠ¤ã€æ§½ä½å¡«å……
âœ… **è¯¦ç»†çš„æŠ€èƒ½å®ç°**: æ ‡å‡†åŒ–æ¥å£ã€å…·ä½“ä»£ç ç¤ºä¾‹ã€è¡¥å¿æœºåˆ¶
âœ… **å¢å¼ºçš„ç¼–æ’èƒ½åŠ›**: SAGAäº‹åŠ¡ã€æ™ºèƒ½è·¯ç”±ã€å¼‚å¸¸å¤„ç†
âœ… **å…¨é¢çš„å®¡è®¡ä½“ç³»**: å†³ç­–æ—¥å¿—ã€æ€§èƒ½ç›‘æ§ã€æˆæœ¬åˆ†æ
âœ… **æ¸è¿›å¼å®æ–½è·¯å¾„**: ä»PoCåˆ°å…¨é¢éƒ¨ç½²çš„æ¸…æ™°è·¯çº¿å›¾
âœ… **ä¸°å¯Œçš„SOPç¤ºä¾‹**: è¦†ç›–å¤šç§ä¸šåŠ¡åœºæ™¯çš„å®é™…æ¨¡æ¿

é€šè¿‡è¿™å¥—æ–¹æ¡ˆ,æ‚¨çš„AIåŠ©æ‰‹å°†ä¸å†åªæ˜¯"èŠå¤©æœºå™¨äºº",è€Œæ˜¯çœŸæ­£å…·å¤‡ä»£ç†èƒ½åŠ›ã€èƒ½å¤Ÿè‡ªä¸»å®Œæˆå¤æ‚ä¸šåŠ¡æ“ä½œçš„æ™ºèƒ½ç³»ç»Ÿã€‚

**ä¸‹ä¸€æ­¥è¡ŒåŠ¨å»ºè®®**:
1. ç»„å»ºæ ¸å¿ƒæŠ€æœ¯å›¢é˜Ÿ(3-5äºº)
2. å¯åŠ¨Phase 0 PoC(4-6å‘¨)
3. é€‰æ‹©1-2ä¸ªé«˜ä»·å€¼ä¸šåŠ¡åœºæ™¯ä½œä¸ºè¯•ç‚¹
4. å»ºç«‹æŒç»­åé¦ˆå’Œä¼˜åŒ–æœºåˆ¶
